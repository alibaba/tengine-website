<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Модуль ngx_http_core_module</title><style type="text/css">body { font-family: Georgia, serif; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #EEEEEE; padding: 10pt 10pt 10pt 0; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: 5pt 0 0 0; font-size: 80%; } div#banner { background: #EEEEEE; padding: 10pt 10pt 10pt 0; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} li { text-align: justify; padding-top: 0.5em; } .compact li { padding-top: 0; } dt { padding-top: 0.5em; } .compact dt { padding-top: 0; } dd { text-align: justify; } td.list { background: #EEEEEE; } blockquote.note { text-align: justify; background: #EEEEEE; border: none; margin: 1em; padding: 0.5em; } blockquote.example { background: transparent; border: none; margin: 1em; padding: 0.5em; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; }</style><script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-27974099-2']);
        _gaq.push(['_setDomainName', 'nginx.org']);
        _gaq.push(['_trackPageview']);

        (function() {
           var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
           ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
           var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script></head><body><table width="100%"><tr><td width="70%"><div id="banner"><center><table><tr><td align="center"><a href="http://nginx.com/support.html"><strong>nginx professional services</strong></a></td></tr><tr><td align="center"><i>Prioritize. Save time. Stay focused.</i></td></tr></table></center></div></td><td align="right"><a href="http://nginx.org"><img src="http://nginx.org/nginx.gif" alt="nginx" border="0"></a></td></tr><tr><td width="70%"><center><h3>Модуль ngx_http_core_module</h3></center></td><td rowspan="2" align="right" valign="top"><br><a href="../../../en/docs/http/ngx_http_core_module.html">english</a><br>русский<br><br><a href="../../../cn/docs/http/ngx_http_core_module.html">简体中文</a><br><a class="notrans">עברית</a><br><a class="notrans">日本語</a><br><a class="notrans">türkçe</a><br><br><a href="../../../">новости</a> [en]<br><a href="../../../ru/">об nginx</a><br><a href="../../../ru/download.html">скачать</a><br><a href="../../../en/security_advisories.html">безопасность</a> [en]<br><a href="../../../en/pgp_keys.html">pgp ключи</a> [en]<br><a href="../../../ru/docs/">документация</a><br><a href="../../../ru/docs/faq.html">faq</a><br><a href="../../../en/links.html">ссылки</a> [en]<br><a href="../../../en/books.html">книги</a> [en]<br><a href="../../../ru/support.html">поддержка</a><br><a href="../../../en/donation.html">пожертвования</a> [en]<br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://wiki.nginx.org/">wiki</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="http://www.nginx.com/">nginx.com</a><br></td></tr><tr><td valign="top"><table width="100%"><tr><td align="left"><a href="#directives">Директивы</a><br>     <a href="#aio">aio</a><br>     <a href="#alias">alias</a><br>     <a href="#chunked_transfer_encoding">chunked_transfer_encoding</a><br>     <a href="#client_body_buffer_size">client_body_buffer_size</a><br>     <a href="#client_body_in_file_only">client_body_in_file_only</a><br>     <a href="#client_body_in_single_buffer">client_body_in_single_buffer</a><br>     <a href="#client_body_temp_path">client_body_temp_path</a><br>     <a href="#client_body_timeout">client_body_timeout</a><br>     <a href="#client_header_buffer_size">client_header_buffer_size</a><br>     <a href="#client_header_timeout">client_header_timeout</a><br>     <a href="#client_max_body_size">client_max_body_size</a><br>     <a href="#connection_pool_size">connection_pool_size</a><br>     <a href="#default_type">default_type</a><br>     <a href="#directio">directio</a><br>     <a href="#directio_alignment">directio_alignment</a><br>     <a href="#disable_symlinks">disable_symlinks</a><br>     <a href="#error_page">error_page</a><br>     <a href="#etag">etag</a><br>     <a href="#http">http</a><br>     <a href="#if_modified_since">if_modified_since</a><br>     <a href="#ignore_invalid_headers">ignore_invalid_headers</a><br>     <a href="#internal">internal</a><br>     <a href="#keepalive_disable">keepalive_disable</a><br>     <a href="#keepalive_requests">keepalive_requests</a><br>     <a href="#keepalive_timeout">keepalive_timeout</a><br>     <a href="#large_client_header_buffers">large_client_header_buffers</a><br>     <a href="#limit_except">limit_except</a><br>     <a href="#limit_rate">limit_rate</a><br>     <a href="#limit_rate_after">limit_rate_after</a><br>     <a href="#lingering_close">lingering_close</a><br>     <a href="#lingering_time">lingering_time</a><br>     <a href="#lingering_timeout">lingering_timeout</a><br>     <a href="#listen">listen</a><br>     <a href="#location">location</a><br>     <a href="#log_not_found">log_not_found</a><br>     <a href="#log_subrequest">log_subrequest</a><br>     <a href="#max_ranges">max_ranges</a><br>     <a href="#merge_slashes">merge_slashes</a><br>     <a href="#msie_padding">msie_padding</a><br>     <a href="#msie_refresh">msie_refresh</a><br>     <a href="#open_file_cache">open_file_cache</a><br>     <a href="#open_file_cache_errors">open_file_cache_errors</a><br>     <a href="#open_file_cache_min_uses">open_file_cache_min_uses</a><br>     <a href="#open_file_cache_valid">open_file_cache_valid</a><br>     <a href="#optimize_server_names">optimize_server_names</a><br>     <a href="#port_in_redirect">port_in_redirect</a><br>     <a href="#postpone_output">postpone_output</a><br>     <a href="#read_ahead">read_ahead</a><br>     <a href="#recursive_error_pages">recursive_error_pages</a><br>     <a href="#request_pool_size">request_pool_size</a><br>     <a href="#reset_timedout_connection">reset_timedout_connection</a><br>     <a href="#resolver">resolver</a><br>     <a href="#resolver_timeout">resolver_timeout</a><br>     <a href="#root">root</a><br>     <a href="#satisfy">satisfy</a><br>     <a href="#satisfy_any">satisfy_any</a><br>     <a href="#send_lowat">send_lowat</a><br>     <a href="#send_timeout">send_timeout</a><br>     <a href="#sendfile">sendfile</a><br>     <a href="#sendfile_max_chunk">sendfile_max_chunk</a><br>     <a href="#server">server</a><br>     <a href="#server_name">server_name</a><br>     <a href="#server_name_in_redirect">server_name_in_redirect</a><br>     <a href="#server_names_hash_bucket_size">server_names_hash_bucket_size</a><br>     <a href="#server_names_hash_max_size">server_names_hash_max_size</a><br>     <a href="#server_tokens">server_tokens</a><br>     <a href="#tcp_nodelay">tcp_nodelay</a><br>     <a href="#tcp_nopush">tcp_nopush</a><br>     <a href="#try_files">try_files</a><br>     <a href="#types">types</a><br>     <a href="#types_hash_bucket_size">types_hash_bucket_size</a><br>     <a href="#types_hash_max_size">types_hash_max_size</a><br>     <a href="#underscores_in_headers">underscores_in_headers</a><br>     <a href="#variables_hash_bucket_size">variables_hash_bucket_size</a><br>     <a href="#variables_hash_max_size">variables_hash_max_size</a><br><a href="#variables">Встроенные переменные</a><br></td></tr></table>

<a name="directives"></a><center><h4>Директивы</h4></center><a name="aio"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>aio</strong> 
    <code>on</code> |
    <code>off</code> |
    <code>sendfile</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>aio off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.11.

            </p></div><p>
Разрешает или запрещает использование файлового асинхронного ввода-вывода (AIO)
во FreeBSD и Linux.
</p><p>
Во FreeBSD AIO можно использовать, начиная с FreeBSD 4.3.
AIO можно либо собрать в ядре статически:
</p> <blockquote class="example"><pre>
options VFS_AIO
</pre></blockquote><p> 
либо загрузить динамически через загружаемый модуль ядра:
</p> <blockquote class="example"><pre>
kldload aio
</pre></blockquote><p> 
</p><p>
В версиях FreeBSD 5 и 6 включение AIO статически или динамически
на стадии загрузки ядра приводит к тому, что вся сетевая подсистема
будет использовать блокировку Giant, что может негативно сказаться на
производительности системы в целом.
Это ограничение устранено во FreeBSD 6.4-STABLE в 2009 году
и во FreeBSD 7.
Однако, начиная с FreeBSD 5.3 есть возможность включать AIO,
не связывая сетевую подсистему блокировкой Giant — для этого модуль
AIO нужно подгружать уже после загрузки ядра.
В этом случае в <code>/var/log/messages</code> появится следующее сообщение:
</p> <blockquote class="example"><pre>
WARNING: Network stack Giant-free, but aio requires Giant.
Consider adding 'options NET_WITH_GIANT' or setting debug.mpsafenet=0
</pre></blockquote><p> 
которое можно смело проигнорировать.
</p> <blockquote class="note">
Требование использовать блокировку Giant в AIO связано с тем, что
FreeBSD поддерживает асинхронные вызовы
<code>aio_read()</code>
и
<code>aio_write()</code>
для работы с сокетами.
Но поскольку nginx использует AIO только для работы с диском,
то проблем не возникает.
</blockquote><p> 
</p><p>
Для работы AIO нужно выключить
<a href="#sendfile">sendfile</a>:
</p> <blockquote class="example"><pre>
location /video/ {
    sendfile       off;
    aio            on;
    output_buffers 1 64k;
}
</pre></blockquote><p> 
</p><p>
Кроме того, начиная с FreeBSD 5.2.1 и nginx 0.8.12, AIO также можно
использовать для подгрузки данных для <code>sendfile()</code>:
</p> <blockquote class="example"><pre>
location /video/ {
    sendfile       on;
    tcp_nopush     on;
    aio            sendfile;
}
</pre></blockquote><p> 
В такой конфигурации функция <code>sendfile()</code> вызывается с флагом
<code>SF_NODISKIO</code>, в результате она не блокируется на диске, а
сообщает об отсутствии данных в памяти, после чего nginx инициирует
асинхронную подгрузку данных, читая только один байт.
При этом ядро FreeBSD подгружает в память первые 128K байт файла, однако
при последующих чтениях файл подгружается частями только по 16K.
Изменить это можно с помощью директивы
<a href="#read_ahead">read_ahead</a>.
</p><p>
В Linux AIO можно использовать только начиная с версии ядра 2.6.22, и,
кроме того, ещё необходимо дополнительно включать
<a href="#directio">directio</a>,
иначе чтение будет блокирующимся:
</p> <blockquote class="example"><pre>
location /video/ {
    aio            on;
    directio       512;
    output_buffers 1 128k;
}
</pre></blockquote><p> 
</p><p>
Поскольку
<a href="#directio">directio</a>
в Linux можно использовать только для чтения блоков, выравненных
на границу 512 байт (или 4К для XFS), то невыравненный конец файла
будет читаться блокированно.
То же относится к запросам с указанием диапазона запрашиваемых байт
(byte-range requests) и к запросам FLV не с начала файла: чтение
невыравненных начала и конца ответа будет блокирующимся.
Явно выключать
<a href="#sendfile">sendfile</a>
не нужно, так как при использовании
<a href="#directio">directio</a>
он выключается автоматически.
</p><a name="alias"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>alias</strong> <code><i>путь</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт замену для указанного location’а.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
location /i/ {
    alias /data/w3/images/;
}
</pre></blockquote><p> 
на запрос
“<code>/i/top.gif</code>” будет отдан файл
<code>/data/w3/images/top.gif</code>.
</p><p>
В значении параметра <code><i>путь</i></code> можно использовать переменные,
кроме <code>$document_root</code> и <code>$realpath_root</code>.
</p><p>
Если <code>alias</code> используется внутри location’а, заданного
регулярным выражением, то регулярное выражение должно содержать
выделения, а сам <code>alias</code> — ссылки на эти выделения
(0.7.40), например:
</p> <blockquote class="example"><pre>
location ~ ^/users/(.+\.(?:gif|jpe?g|png))$ {
    alias /data/w3/images/$1;
}
</pre></blockquote><p> 
</p><p>
Если location и последняя часть значения директивы совпадают:
</p> <blockquote class="example"><pre>
location /images/ {
    alias /data/w3/images/;
}
</pre></blockquote><p> 
то лучше воспользоваться директивой
<a href="#root">root</a>:
</p> <blockquote class="example"><pre>
location /images/ {
    root /data/w3;
}
</pre></blockquote><p> 
</p><a name="chunked_transfer_encoding"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>chunked_transfer_encoding</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>chunked_transfer_encoding on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет запретить формат передачи данных частями (chunked transfer
encoding) в HTTP/1.1.
Это может понадобиться при использовании программ, не поддерживающих
chunked encoding, несмотря на требования стандарта.
</p><a name="client_body_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_body_buffer_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_body_buffer_size 8k|16k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер буфера для чтения тела запроса клиента.
Если тело запроса больше заданного буфера,
то всё тело запроса или только его часть записывается во
<a href="#client_body_temp_path">временный файл</a>.
По умолчанию размер одного буфера равен двум размерам страницы.
На x86, других 32-битных платформах и x86-64 это 8K.
На других 64-битных платформах это обычно 16K.
</p><a name="client_body_in_file_only"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_body_in_file_only</strong> 
    <code>on</code> |
    <code>clean</code> |
    <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_body_in_file_only off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет, сохранять ли всё тело запроса клиента в файл.
Директиву можно использовать для отладки и при использовании переменной
<code>$request_body_file</code>
или метода
<a href="ngx_http_perl_module.html#methods">$r-&gt;request_body_file</a>
модуля
<a href="ngx_http_perl_module.html">ngx_http_perl_module</a>.
</p><p>
При установке значения <code>on</code> временные файлы
по окончании обработки запроса не удаляются.
</p><p>
Значение <code>clean</code> разрешает удалять временные файлы,
оставшиеся по окончании обработки запроса.
</p><a name="client_body_in_single_buffer"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_body_in_single_buffer</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_body_in_single_buffer off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет, сохранять ли всё тело запроса клиента в одном буфере.
Директива рекомендуется при использовании переменной
<code>$request_body</code>
для уменьшения требуемого числа операций копирования.
</p><a name="client_body_temp_path"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_body_temp_path</strong> 
    <code><i>путь</i></code>
    [<code><i>уровень1</i></code>
    [<code><i>уровень2</i></code>
    [<code><i>уровень3</i></code>]]];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_body_temp_path client_body_temp;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт каталог для хранения временных файлов с телами запросов клиентов.
В каталоге может использоваться иерархия подкаталогов до трёх уровней.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
client_body_temp_path /spool/nginx/client_temp 1 2;
</pre></blockquote><p> 
временный файл будет следующего вида:
</p> <blockquote class="example"><pre>
/spool/nginx/client_temp/7/45/00000123457
</pre></blockquote><p> 
</p><a name="client_body_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_body_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_body_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при чтении тела запроса клиента.
Таймаут устанавливается не на всю передачу тела запроса,
а только между двумя последовательными операциями чтения.
Если по истечении этого времени клиент ничего не передаст,
то клиенту возвращается ошибка
408 (Request Time-out).
</p><a name="client_header_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_header_buffer_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_header_buffer_size 1k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер буфера для чтения заголовка запроса клиента.
Для большинства запросов достаточно буфера размером в 1K байт.
Однако если в запросе есть длинные cookies, или же запрос
пришёл от WAP-клиента, то он может не поместиться в 1K.
Поэтому, если строка запроса или поле заголовка запроса
не помещаются полностью в этот буфер, то выделяются буферы
большего размера, задаваемые директивой
<a href="#large_client_header_buffers">large_client_header_buffers</a>.
</p><a name="client_header_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_header_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_header_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при чтении заголовка запроса клиента.
Если по истечении этого времени клиент не передаст полностью заголовок,
то клиенту возвращается ошибка
408 (Request Time-out).
</p><a name="client_max_body_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>client_max_body_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>client_max_body_size 1m;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимально допустимый размер тела запроса клиента,
указываемый в поле
“Content-Length”
заголовка запроса.
Если размер больше заданного, то клиенту возвращается ошибка
413 (Request Entity Too Large).
Следует иметь в виду, что
браузеры не умеют корректно показывать
эту ошибку.
Установка параметра <code><i>размер</i></code> в 0 отключает
проверку размера тела запроса клиента.
</p><a name="connection_pool_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>connection_pool_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>connection_pool_size 256;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет производить точную настройку выделений памяти
под конкретные соединения.
Эта директива не оказывает существенного влияния на
производительность и её не следует использовать.
</p><a name="default_type"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>default_type</strong> <code><i>mime-тип</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>default_type text/plain;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт MIME-тип ответов по умолчанию.
Соответствие расширений имён файлов MIME-типу ответов задаётся
с помощью директивы <a href="#types">types</a>.
</p><a name="directio"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>directio</strong> <code><i>размер</i></code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>directio off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.7.7.

            </p></div><p>
Разрешает использовать флаги
<code>O_DIRECT</code> (FreeBSD, Linux),
<code>F_NOCACHE</code> (Mac OS X)
или функцию <code>directio()</code> (Solaris)
при чтении файлов, размер которых больше либо равен указанному.
Директива автоматически запрещает (0.7.15) использование
<a href="#sendfile">sendfile</a>
для данного запроса.
Рекомендуется использовать для больших файлов:
</p> <blockquote class="example"><pre>
directio 4m;
</pre></blockquote><p> 
или при использовании <a href="#aio">aio</a> в Linux.
</p><a name="directio_alignment"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>directio_alignment</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>directio_alignment 512;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.11.

            </p></div><p>
Устанавливает выравнивание для
<a href="#directio">directio</a>.
В большинстве случаев достаточно 512-байтового выравнивания, однако
при использовании XFS под Linux его нужно увеличить до 4K.
</p><a name="disable_symlinks"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>disable_symlinks</strong> <code>off</code>;</code><br><code><strong>disable_symlinks</strong> 
    <code>on</code> |
    <code>if_not_owner</code>
    [<code>from</code>=<code><i>часть</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>disable_symlinks off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.1.15.

            </p></div><p>
Определяет, как следует поступать с символическими ссылками
при открытии файлов:
</p> <dl class="compact">

<dt><code>off</code></dt>
<dd>
Символические ссылки в пути допускаются и не проверяются.
Это стандартное поведение.
</dd>

<dt><code>on</code></dt>
<dd>
Если любой компонент пути является символической ссылкой,
доступ к файлу запрещается.
</dd>

<dt><code>if_not_owner</code></dt>
<dd>
Доступ к файлу запрещается, если любой компонент пути
является символической ссылкой, а ссылка и объект, на
который она ссылается, имеют разных владельцев.
</dd>

<dt><code>from</code>=<code><i>часть</i></code></dt>
<dd>
При проверке символических ссылок
(параметры <code>on</code> и <code>if_not_owner</code>)
обычно проверяются все компоненты пути.
Можно не проверять символические ссылки в начальной части пути,
указав дополнительно параметр
<code>from</code>=<code><i>часть</i></code>.
В этом случае символические ссылки проверяются лишь начиная
с компонента пути, который следует за заданной начальной частью.
Если значение не является начальной частью проверяемого пути,
путь проверяется целиком, как если бы этот параметр не был указан вовсе.
Если значение целиком совпадает с именем файла,
символические ссылки не проверяются.
В значении параметра можно использовать переменные.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
disable_symlinks on from=$document_root;
</pre></blockquote><p> 
</p><p>
Эта директива доступна только на системах, в которых есть
интерфейсы <code>openat()</code> и <code>fstatat()</code>.
К таким системам относятся современные версии FreeBSD, Linux и Solaris.
</p><p>
Параметры <code>on</code> и <code>if_not_owner</code>
требуют дополнительных затрат на обработку.
</p> <blockquote class="note">
На системах, не поддерживающих операцию открытия каталогов только для поиска,
использование этих параметров требует, чтобы рабочие процессы
имели право читать все проверяемые каталоги.
</blockquote><p> 
</p><p>
</p> <blockquote class="note">
Модули
<a href="ngx_http_autoindex_module.html">ngx_http_autoindex_module</a>,
<a href="ngx_http_random_index_module.html">ngx_http_random_index_module</a>
и <a href="ngx_http_dav_module.html">ngx_http_dav_module</a>
в настоящий момент игнорируют эту директиву.
</blockquote><p> 
</p><a name="error_page"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>error_page</strong> 
    <code><i>код</i></code> ...
    [<code>=</code>[<code><i>ответ</i></code>]]
    <code><i>uri</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт URI, который будет показываться для указанных ошибок.
Директивы <code>error_page</code> наследуются с предыдущего уровня
при условии, что на данном уровне не описаны свои директивы
<code>error_page</code>.
В значении <code>uri</code> можно использовать переменные.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
error_page 404             /404.html;
error_page 500 502 503 504 /50x.html;
</pre></blockquote><p> 
</p><p>
Кроме того, можно поменять код ответа на другой,
используя синтаксис вида “<code>=</code><code><i>ответ</i></code>”, например:
</p> <blockquote class="example"><pre>
error_page 404 =200 /empty.gif;
</pre></blockquote><p> 
</p><p>
Если ошибочный ответ обрабатывается проксированным сервером или
FastCGI-сервером, и этот сервер может вернуть разные коды ответов,
например, 200, 302, 401 или 404, то можно выдавать возвращаемый им код:
</p> <blockquote class="example"><pre>
error_page 404 = /404.php;
</pre></blockquote><p> 
</p><p>
Также существует возможность использовать перенаправления для обработки
ошибок:
</p> <blockquote class="example"><pre>
error_page 403      http://example.com/forbidden.html;
error_page 404 =301 http://example.com/notfound.html;
</pre></blockquote><p> 
В этому случае клиенту возвращается код ответа 302.
Его можно изменить только на один из кодов статуса, относящихся к
перенаправлениям (301, 302, 303 и 307).
</p><p>
Если при внутреннем перенаправлении не нужно менять URI, то можно передать
обработку ошибки в именованный location:
</p> <blockquote class="example"><pre>
location / {
    error_page 404 = @fallback;
}

location @fallback {
    proxy_pass http://backend;
}
</pre></blockquote><p> 
</p><p>
</p> <blockquote class="note">
Если при обработке <code>uri</code> происходит ошибка,
клиенту возвращается ответ с кодом статуса последней случившейся ошибки.
</blockquote><p> 
</p><a name="etag"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>etag</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>etag on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.3.3.

            </p></div><p>
Разрешает или запрещает автоматическую генерацию поля “ETag”
заголовка ответа для статических ресурсов.
</p><a name="http"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>http</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>main</code><br>
                </td>
                </tr>
            </table></div><p>
Предоставляет контекст конфигурационного файла, в котором указываются
директивы HTTP-сервера.
</p><a name="if_modified_since"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>if_modified_since</strong> 
    <code>off</code> |
    <code>exact</code> |
    <code>before</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>if_modified_since exact;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.7.24.

            </p></div><p>
Определяет, как сравнивать время модификации ответа с
временем в поле
“If-Modified-Since”
заголовка запроса:

</p> <dl class="compact">

<dt><code>off</code></dt>
<dd>
не проверять поле
“If-Modified-Since” заголовка запроса (0.7.34);
</dd>

<dt><code>exact</code></dt>
<dd>
точное совпадение;
</dd>

<dt><code>before</code></dt>
<dd>
время модификации ответа меньше или равно времени, заданному в поле
“If-Modified-Since” заголовка запроса.
</dd>

</dl><p> 
</p><a name="ignore_invalid_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>ignore_invalid_headers</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>ignore_invalid_headers on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Если включено, nginx игнорирует поля заголовка с недопустимыми именами.
Допустимыми считаются имена, состоящие из английских букв, цифр, дефисов
и возможно знаков подчёркивания (последнее контролируется директивой
<a href="#underscores_in_headers">underscores_in_headers</a>).
</p><p>
Директива может быть указана на уровне <a href="#server">server</a>
в сервере по умолчанию.
В этом случае её значение распространяется на все виртуальные серверы,
слушающие на том же адресе и порту.
</p><a name="internal"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>internal</strong>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Указывает, что location может использоваться только для внутренних запросов.
Для внешних запросов клиенту будет возвращаться ошибка
404 (Not Found).
Внутренними запросами являются:

</p> <ul class="compact">

<li>
запросы, перенаправленные директивами
<a href="#error_page">error_page</a>,
<a href="ngx_http_index_module.html#index">index</a>,
<a href="ngx_http_random_index_module.html#random_index">random_index</a> и
<a href="#try_files">try_files</a>;
</li>

<li>
запросы, перенаправленные с помощью поля
“X-Accel-Redirect” заголовка ответа вышестоящего сервера;
</li>

<li>
подзапросы, формируемые командой
“<code>include virtual</code>”
модуля
<a href="ngx_http_ssi_module.html">ngx_http_ssi_module</a>
и директивами модуля
<a href="ngx_http_addition_module.html">ngx_http_addition_module</a>;
</li>

<li>
запросы, изменённые директивой
<a href="ngx_http_rewrite_module.html#rewrite">rewrite</a>.
</li>

</ul><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
error_page 404 /404.html;

location /404.html {
    internal;
}
</pre></blockquote><p> 
</p> <blockquote class="note">
Для предотвращения зацикливания, которое может возникнуть при
использовании некорректных конфигураций, количество внутренних
перенаправлений ограничено десятью.
По достижении этого ограничения будет возвращена ошибка
500 (Internal Server Error).
В таком случае в лог-файле ошибок можно увидеть сообщение
“rewrite or internal redirection cycle”.
</blockquote><p> 
</p><a name="keepalive_disable"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>keepalive_disable</strong> <code>none</code> | <code><i>браузер</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>keepalive_disable msie6;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Запрещает keep-alive соединения с некорректно ведущими себя браузерами.
Параметры <code><i>браузер</i></code> указывают, на какие браузеры это
распространяется.
Значение <code>msie6</code> запрещает keep-alive соединения
со старыми версиями MSIE после получения запроса POST.
Значение <code>safari</code> запрещает keep-alive соединения
с Safari и подобными им браузерами на Mac OS X и подобных ей ОС.
Значение <code>none</code> разрешает keep-alive соединения
со всеми браузерами.
</p> <blockquote class="note">
До версии 1.1.18 под значение <code>safari</code> подпадали
все Safari и подобные им браузеры на всех ОС, и keep-alive
соединения с ними были по умолчанию запрещены.
</blockquote><p> 
</p><a name="keepalive_requests"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>keepalive_requests</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>keepalive_requests 100;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.0.

            </p></div><p>
Задаёт максимальное число запросов, которые можно
сделать по одному keep-alive соединению.
После того, как будет сделано максимальное число запросов,
соединение закрывается.
</p><a name="keepalive_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>keepalive_timeout</strong> 
    <code><i>таймаут</i></code>
    [<code><i>заголовок_таймаута</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>keepalive_timeout 75s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Первый параметр задаёт таймаут, в течение которого keep-alive
соединение с клиентом не будет закрыто со стороны сервера.
Второй необязательный параметр задаёт значение в поле
“Keep-Alive: timeout=<code><i>время</i></code>”
заголовка ответа.
Два параметра могут отличаться друг от друга.
</p><p>
Поле
“Keep-Alive: timeout=<code><i>время</i></code>”
заголовка понимают Mozilla и Konqueror.
MSIE сам закрывает keep-alive соединение примерно через 60 секунд.
</p><a name="large_client_header_buffers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>large_client_header_buffers</strong> <code><i>число</i></code> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>large_client_header_buffers 4 8k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальное <code><i>число</i></code> и <code><i>размер</i></code>
буферов для чтения большого заголовка запроса клиента.
Строка запроса не должна превышать размера одного буфера, иначе клиенту
возвращается ошибка
414 (Request-URI Too Large).
Поле заголовка запроса также не должно превышать размера одного буфера,
иначе клиенту возвращается ошибка
400 (Bad Request).
Буферы выделяются только по мере необходимости.
По умолчанию размер одного буфера равен 8K байт.
Если по окончании обработки запроса соединение переходит в состояние
keep-alive, эти буферы освобождаются.
</p><a name="limit_except"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>limit_except</strong> <code><i>метод</i></code> ... { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Ограничивает HTTP-методы, доступные внутри location.
Параметр <code><i>метод</i></code> может быть одним из
<code>GET</code>,
<code>HEAD</code>,
<code>POST</code>,
<code>PUT</code>,
<code>DELETE</code>,
<code>MKCOL</code>,
<code>COPY</code>,
<code>MOVE</code>,
<code>OPTIONS</code>,
<code>PROPFIND</code>,
<code>PROPPATCH</code>,
<code>LOCK</code>,
<code>UNLOCK</code>
или
<code>PATCH</code>.
Если разрешён метод <code>GET</code>, то метод
<code>HEAD</code> также будет разрешён.
Доступ к остальным методам может быть ограничен при помощи директив модулей
<a href="ngx_http_access_module.html">ngx_http_access_module</a>
и
<a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>:
</p> <blockquote class="example"><pre>
limit_except GET {
    allow 192.168.1.0/32;
    deny  all;
}
</pre></blockquote><p> 
Обратите внимание, что данное ограничение действует для всех методов,
<strong>кроме</strong> GET и HEAD.
</p><a name="limit_rate"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>limit_rate</strong> <code><i>скорость</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>limit_rate 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Ограничивает скорость передачи ответа клиенту.
Скорость задаётся в байтах в секунду.
Значение 0 отключает ограничение скорости.

Ограничение устанавливается на запрос, поэтому если клиент одновременно
откроет два соединения, суммарная скорость будет вдвое выше
заданного ограничения.
</p><p>
Ограничение скорости можно также задать в переменной <code>$limit_rate</code>.
Это может быть полезно в случаях, когда скорость нужно ограничивать
в зависимости от какого-либо условия:
</p> <blockquote class="example"><pre>
server {

    if ($slow) {
        set $limit_rate 4k;
    }

    ...
}
</pre></blockquote><p> 
</p><p>
Кроме того, ограничение скорости может быть задано в поле
“X-Accel-Limit-Rate” заголовка ответа проксированного сервера.
Эту возможность можно запретить с помощью директив
<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a>
и
<a href="ngx_http_fastcgi_module.html#fastcgi_ignore_headers">fastcgi_ignore_headers</a>.
</p><a name="limit_rate_after"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>limit_rate_after</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>limit_rate_after 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 0.8.0.

            </p></div><p>
Задаёт начальный объём данных, после передачи которого начинает
ограничиваться скорость передачи ответа клиенту.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
location /flv/ {
    flv;
    limit_rate_after 500k;
    limit_rate       50k;
}
</pre></blockquote><p> 
</p><a name="lingering_close"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>lingering_close</strong> 
    <code>off</code> |
    <code>on</code> |
    <code>always</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>lingering_close on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table>
                        <p>
                    Эта директива появилась в версиях 1.1.0 и 1.0.6.
                  
                        </p>
                    </div><p>
Управляет закрытием соединений с клиентами.
</p><p>
Со значением по умолчанию “<code>on</code>” nginx будет
<a href="#lingering_timeout">ждать</a> и
<a href="#lingering_time">обрабатывать</a> дополнительные данные,
поступающие от клиента, перед полным закрытием соединения, но только
если эвристика указывает на то, что клиент может ещё послать данные.
</p><p>
Со значением “<code>always</code>” nginx всегда будет
ждать и обрабатывать дополнительные данные, поступающие от клиента.
</p><p>
Со значением “<code>off</code>” nginx не будет ждать поступления
дополнительных данных и сразу же закроет соединение.
Это нарушает протокол, поэтому не следует это использовать без нужды.
</p><a name="lingering_time"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>lingering_time</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>lingering_time 30s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если действует <a href="#lingering_close">lingering_close</a>,
эта директива задаёт максимальное время, в течение которого nginx
будет обрабатывать (читать и игнорировать) дополнительные данные,
поступающие от клиента.
По прошествии этого времени соединение будет закрыто, даже если
будут ещё данные.
</p><a name="lingering_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>lingering_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>lingering_timeout 5s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если действует <a href="#lingering_close">lingering_close</a>, эта директива задаёт
максимальное время ожидания поступления дополнительных данных от клиента.
Если в течение этого времени данные не были получены, соединение закрывается.
Иначе данные читаются и игнорируются, затем nginx снова ждёт поступления данных.
Цикл “ждать-читать-игнорировать” повторяется, но не дольше чем задано
директивой <a href="#lingering_time">lingering_time</a>.
</p><a name="listen"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>listen</strong> 
    <code><i>адрес</i></code>[:<code><i>порт</i></code>]
    [<code>default_server</code>]
    [<code>setfib</code>=<code><i>число</i></code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>ipv6only</code>=<code>on</code>|<code>off</code>]
    [<code>ssl</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br><code><strong>listen</strong> 
    <code><i>порт</i></code>
    [<code>default_server</code>]
    [<code>setfib</code>=<code><i>число</i></code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>ipv6only</code>=<code>on</code>|<code>off</code>]
    [<code>ssl</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br><code><strong>listen</strong> 
    <code>unix:</code><code><i>путь</i></code>
    [<code>default_server</code>]
    [<code>backlog</code>=<code><i>число</i></code>]
    [<code>rcvbuf</code>=<code><i>размер</i></code>]
    [<code>sndbuf</code>=<code><i>размер</i></code>]
    [<code>accept_filter</code>=<code><i>фильтр</i></code>]
    [<code>deferred</code>]
    [<code>bind</code>]
    [<code>ssl</code>]
    [<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>listen *:80 | *:8000;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт <code><i>адрес</i></code> и <code><i>порт</i></code> для IP
или <code><i>путь</i></code> для UNIX-сокета,
на которых сервер будет принимать запросы.
Можно указать только <code><i>адрес</i></code>
или только <code><i>порт</i></code>.
Кроме того, <code><i>адрес</i></code> может быть именем хоста, например:
</p> <blockquote class="example"><pre>
listen 127.0.0.1:8000;
listen 127.0.0.1;
listen 8000;
listen *:8000;
listen localhost:8000;
</pre></blockquote><p> 
IPv6-адреса (0.7.36) задаются в квадратных скобках:
</p> <blockquote class="example"><pre>
listen [::]:8000;
listen [fe80::1];
</pre></blockquote><p> 
UNIX-сокеты (0.8.21) задаются при помощи префикса “<code>unix:</code>”:
</p> <blockquote class="example"><pre>
listen unix:/var/run/nginx.sock;
</pre></blockquote><p> 
</p><p>
Если указан только <code><i>адрес</i></code>, то используется порт 80.
</p><p>
Если директива не указана, то используется либо <code>*:80</code>
(если nginx работает с привилегиями суперпользователя),
либо <code>*:8000</code>.
</p><p>
Если у директивы есть параметр <code>default_server</code>, то сервер,
в котором описана эта директива, будет сервером по умолчанию для указанной пары
<code><i>адрес</i></code>:<code><i>порт</i></code>.
Если же директив с параметром <code>default_server</code> нет, то
сервером по умолчанию будет первый сервер, в котором описана пара
<code><i>адрес</i></code>:<code><i>порт</i></code>.
</p> <blockquote class="note">
До версии 0.8.21 этот параметр назывался просто
<code>default</code>.
</blockquote><p> 
</p><p>
В директиве <code>listen</code> можно также указать несколько
дополнительных параметров, специфичных для связанных с сокетами
системных вызовов.
Эти параметры можно задать в любой директиве <code>listen</code>,
но только один раз для указанной пары
<code><i>адрес</i></code>:<code><i>порт</i></code>.
</p> <blockquote class="note">
До версии 0.8.21 их можно было указывать лишь в директиве
<code>listen</code> совместно с параметром <code>default</code>.
</blockquote><p> 
</p> <dl class="compact">

<dt>
<code>setfib</code>=<code><i>число</i></code>
</dt>
<dd>
этот параметр (0.8.44) задаёт таблицу маршрутизации, FIB
(параметр <code>SO_SETFIB</code>) для слушающего сокета.
В настоящий момент это работает только на FreeBSD.
</dd>

<dt>
<code>backlog</code>=<code><i>число</i></code>
</dt>
<dd>
задаёт параметр <code>backlog</code> в вызове
<code>listen()</code>, который ограничивает
максимальный размер очереди ожидающих приёма соединений.
По умолчанию <code>backlog</code> устанавливается равным -1 для
FreeBSD и Mac OS X, и 511 для других платформ.
</dd>

<dt>
<code>rcvbuf</code>=<code><i>размер</i></code>
</dt>
<dd>
задаёт размер буфера приёма
(параметр <code>SO_RCVBUF</code>) для слушающего сокета.
</dd>

<dt>
<code>sndbuf</code>=<code><i>размер</i></code>
</dt>
<dd>
задаёт размер буфера передачи
(параметр <code>SO_SNDBUF</code>) для слушающего сокета.
</dd>

<dt>
<code>accept_filter</code>=<code><i>фильтр</i></code>
</dt>
<dd>
задаёт название accept-фильтра
(параметр <code>SO_ACCEPTFILTER</code>) для слушающего сокета,
который включается для фильтрации входящих соединений
перед передачей их в <code>accept()</code>.
Работает только на FreeBSD и NetBSD 5.0+.
Можно использовать два фильтра —
<a href="http://man.freebsd.org/accf_data">dataready</a>
и
<a href="http://man.freebsd.org/accf_http">httpready</a>.
</dd>

<dt>
<code>deferred</code>
</dt>
<dd>
указывает использовать отложенный <code>accept()</code>
(параметр <code>TCP_DEFER_ACCEPT</code> сокета) на Linux.
</dd>

<dt>
<code>bind</code>
</dt>
<dd>
указывает, что для данной пары
<code><i>адрес</i></code>:<code><i>порт</i></code> нужно делать
<code>bind()</code> отдельно.
Дело в том, что если описаны несколько директив <code>listen</code>
с одинаковым портом, но разными адресами, и одна из директив
<code>listen</code> слушает на всех адресах для данного порта
(<code>*:</code><code><i>порт</i></code>), то nginx сделает
<code>bind()</code> только на <code>*:</code><code><i>порт</i></code>.
Необходимо заметить, что в этом случае для определения адреса, на которой
пришло соединение, делается системный вызов <code>getsockname()</code>.
Если же используются параметры <code>backlog</code>,
<code>rcvbuf</code>, <code>sndbuf</code>,
<code>accept_filter</code>, <code>deferred</code>
или <code>so_keepalive</code>, то для данной пары
<code><i>адрес</i></code>:<code><i>порт</i></code> всегда делается
отдельный вызов <code>bind()</code>.
</dd>

<dt>
<code>ipv6only</code>=<code>on</code>|<code>off</code>
</dt>
<dd>
этот параметр (0.7.42) определяет
(через параметр сокета <code>IPV6_V6ONLY</code>),
будет ли слушающий на wildcard-адресе <code>[::]</code> IPv6-сокет
принимать только IPv6-соединения, или же одновременно IPv6- и IPv4-соединения.
По умолчанию параметр включён.
Установить его можно только один раз на старте.
<blockquote class="note">
До версии 1.3.4,
если этот параметр не был задан явно, то для сокета действовали
настройки операционной системы.
</blockquote>
</dd>

<dt>
<code>ssl</code>
</dt>
<dd>
этот параметр (0.7.14) не имеет отношения к связанным с сокетами системным
вызовам, а позволяет указать, что все соединения, принимаемые на этом порту,
должны работать в режиме SSL.
Это позволяет задать компактную <a href="configuring_https_servers.html#single_http_https_server">конфигурацию</a> для сервера,
работающего сразу в двух режимах — HTTP и HTTPS.
</dd>

<dt>
<code>so_keepalive</code>=<code>on</code>|<code>off</code>|[<code><i>keepidle</i></code>]:[<code><i>keepintvl</i></code>]:[<code><i>keepcnt</i></code>]
</dt>
<dd>
этот параметр (1.1.11) конфигурирует для слушающего сокета
поведение “TCP keepalive”.
Если этот параметр опущен, то для сокета будут действовать
настройки операционной системы.
Если он установлен в значение “<code>on</code>”, то для сокета
включается параметр <code>SO_KEEPALIVE</code>.
Если он установлен в значение “<code>off</code>”, то для сокета
параметр <code>SO_KEEPALIVE</code> выключается.
Некоторые операционные системы поддерживают настройку параметров
“TCP keepalive” на уровне сокета посредством параметров
<code>TCP_KEEPIDLE</code>, <code>TCP_KEEPINTVL</code> и
<code>TCP_KEEPCNT</code>.
На таких системах (в настоящий момент это Linux 2.4+, NetBSD 5+ и
FreeBSD 9.0-STABLE)
их можно сконфигурировать с помощью параметров <code><i>keepidle</i></code>,
<code><i>keepintvl</i></code> и <code><i>keepcnt</i></code>.
Один или два параметра могут быть опущены, в таком случае для
соответствующего параметра сокета будут действовать стандартные
системные настройки.
Например,
<blockquote class="example"><pre>so_keepalive=30m::10</pre></blockquote>
установит таймаут бездействия (<code>TCP_KEEPIDLE</code>) в 30 минут,
для интервала проб (<code>TCP_KEEPINTVL</code>) будет действовать
стандартная системная настройка, а счётчик проб (<code>TCP_KEEPCNT</code>)
будет равен 10.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
listen 127.0.0.1 default_server accept_filter=dataready backlog=1024;
</pre></blockquote><p> 
</p><a name="location"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>location</strong> [
    <code>=</code> |
    <code>~</code> |
    <code>~*</code> |
    <code>^~</code>
    ] <code><i>uri</i></code> { ... }</code><br><code><strong>location</strong> <code>@</code><code><i>имя</i></code> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Устанавливает конфигурацию в зависимости от URI запроса.
</p><p>
Для сопоставления используется URI запроса в нормализованном виде,
после декодирования текста, заданного в виде “<code>%XX</code>”,
преобразования относительных элементов пути “<code>.</code>” и
“<code>..</code>” в реальные, и возможной
<a href="#merge_slashes">замены</a> двух и более подряд идущих
слэшей на один.
</p><p>
location можно задать префиксной строкой или регулярным выражением.
Регулярные выражения задаются либо с модификатором “<code>~*</code>”
(для поиска совпадения без учёта регистра символов),
либо с модификатором “<code>~</code>” (с учётом регистра).
Чтобы найти location, соответствующий запросу, вначале проверяются
location’ы, заданные префиксными строками (префиксные location’ы).
Среди них ищется максимальное совпадение.
Затем проверяются регулярные выражения, в порядке их следования
в конфигурационном файле.
Проверка регулярных выражений прекращается после первого же совпадения,
и используется соответствующая конфигурация.
Если совпадение с регулярным выражением не найдено, то используется
конфигурация максимально совпавшего префиксного location’а.
</p><p>
location’ы могут быть вложенными, с некоторыми исключениями,
о которых говорится ниже.
</p><p>
Для операционных систем, нечувствительных к регистру символов, таких
как Mac OS X и Cygwin, сравнение с префиксными строками производится
без учёта регистра (0.7.7).
Однако, сравнение ограничено только однобайтными locale’ями.
</p><p>
Регулярные выражения могут содержать выделения (0.7.40), которые могут
затем использоваться в других директивах.
</p><p>
Если у максимального совпавшего префиксного location’а указан модификатор
“<code>^~</code>”, то регулярные выражения не проверяются.
</p><p>
Кроме того, с помощью модификатора “<code>=</code>” можно задать точное
совпадение URI и location.
При точном совпадении поиск сразу же прекращается.
Например, если запрос “<code>/</code>” случается часто, то
указав “<code>location = /</code>”, можно ускорить обработку
этих запросов, так как поиск прекратится после первого же сравнения.
Очевидно, что такой location не может иметь вложенные location’ы.
</p><p>
</p> <blockquote class="note">
В версиях с 0.7.1 по 0.8.41, если запрос точно совпал с префиксным
location’ом без модификаторов “<code>=</code>” и “<code>^~</code>”,
то поиск тоже сразу же прекращается и регулярные выражения также
не проверяются.
</blockquote><p> 
</p><p>
Проиллюстрируем вышесказанное примером:
</p> <blockquote class="example"><pre>
location = / {
    [ конфигурация А ]
}

location / {
    [ конфигурация Б ]
}

location /documents/ {
    [ конфигурация В ]
}

location ^~ /images/ {
    [ конфигурация Г ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ конфигурация Д ]
}
</pre></blockquote><p> 
Для запроса “<code>/</code>” будет выбрана конфигурация А,
для запроса “<code>/index.html</code>” — конфигурация Б,
для запроса “<code>/documents/document.html</code>” — конфигурация В,
для запроса “<code>/images/1.gif</code>” — конфигурация Г,
а для запроса “<code>/documents/1.jpg</code>” — конфигурация Д.
</p><p>
Префикс “<code>@</code>” задаёт именованный location.
Такой location не используется при обычной обработке запросов, а
предназначен только для перенаправления в него запросов.
Такие location’ы не могут быть вложенными и не могут содержать
вложенные location’ы.
</p><a name="log_not_found"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>log_not_found</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>log_not_found on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает записывать в
<a href="../ngx_core_module.html#error_log">error_log</a>
ошибки о том, что файл не найден.
</p><a name="log_subrequest"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>log_subrequest</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>log_subrequest off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает записывать в
<a href="ngx_http_log_module.html#access_log">access_log</a>
подзапросы.
</p><a name="max_ranges"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>max_ranges</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>Эта директива появилась в версии 1.1.2.

            </p></div><p>
Ограничивает максимальное допустимое число диапазонов в запросах с
указанием диапазона запрашиваемых байт (byte-range requests).
Запросы, превышающие указанное ограничение, обрабатываются как
если бы они не содержали указания диапазонов.
По умолчанию ограничения нет.
Значение 0 полностью запрещает поддержку диапазонов.
</p><a name="merge_slashes"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>merge_slashes</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>merge_slashes on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает преобразование URI путём замены двух и более подряд
идущих слэшей (“<code>/</code>”) на один.
</p><p>
Необходимо иметь в виду, что это преобразование необходимо для корректной
проверки префиксных строк и регулярных выражений.
Если его не делать, то запрос “<code>//scripts/one.php</code>”
не попадёт в
</p> <blockquote class="example"><pre>
location /scripts/ {
    ...
}
</pre></blockquote><p> 
и может быть обслужен как статический файл.
Поэтому он преобразуется к виду “<code>/scripts/one.php</code>”.
</p><p>
Запрет преобразования может понадобиться, если в URI используются имена,
закодированные методом base64, в котором задействован символ
“<code>/</code>”.
Однако по соображениям безопасности лучше избегать отключения преобразования.
</p><p>
Директива может быть указана на уровне <a href="#server">server</a>
в сервере по умолчанию.
В этом случае её значение распространяется на все виртуальные серверы,
слушающие на том же адресе и порту.
</p><a name="msie_padding"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>msie_padding</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>msie_padding on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает добавлять в ответы для MSIE со статусом больше 400
комментарий для увеличения размера ответа до 512 байт.
</p><a name="msie_refresh"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>msie_refresh</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>msie_refresh off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает выдавать для MSIE клиентов refresh’ы вместо
перенаправлений.
</p><a name="open_file_cache"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>open_file_cache</strong> <code>off</code>;</code><br><code><strong>open_file_cache</strong> 
<code>max</code>=<code><i>N</i></code>
[<code>inactive</code>=<code><i>время</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>open_file_cache off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт кэш, в котором могут храниться:
</p> <ul class="compact">

<li>
дескрипторы открытых файлов, информация об их размерах и времени модификации;
</li>

<li>
информация о существовании каталогов;
</li>

<li>
информация об ошибках поиска файла — “нет файла”, “нет прав на чтение”
и тому подобное.
<blockquote class="note">
Кэширование ошибок нужно разрешить отдельно директивой
<a href="#open_file_cache_errors">open_file_cache_errors</a>.
</blockquote>
</li>

</ul><p> 
</p><p>
У директивы есть следующие параметры:
</p> <dl class="compact">

<dt>
<code>max</code>
</dt>
<dd>
задаёт максимальное число элементов в кэше;
при переполнении кэша удаляются наименее востребованные элементы (LRU);
</dd>

<dt>
<code>inactive</code>
</dt>
<dd>
задаёт время, после которого элемент кэша удаляется, если к нему
не было обращений в течение этого времени; по умолчанию 60 секунд;
</dd>

<dt>
<code>off</code>
</dt>
<dd>
запрещает кэш.
</dd>

</dl><p> 
</p><p>
Пример:
</p> <blockquote class="example"><pre>
open_file_cache          max=1000 inactive=20s;
open_file_cache_valid    30s;
open_file_cache_min_uses 2;
open_file_cache_errors   on;

</pre></blockquote><p> 
</p><a name="open_file_cache_errors"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>open_file_cache_errors</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>open_file_cache_errors off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает кэширование ошибок поиска файлов в
<a href="#open_file_cache">open_file_cache</a>.
</p><a name="open_file_cache_min_uses"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>open_file_cache_min_uses</strong> <code><i>число</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>open_file_cache_min_uses 1;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт минимальное <code><i>число</i></code> обращений к файлу
в течение времени, заданного параметром <code>inactive</code>
директивы <a href="#open_file_cache">open_file_cache</a>, после которого дескриптор
файла будет оставаться открытым в кэше.
</p><a name="open_file_cache_valid"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>open_file_cache_valid</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>open_file_cache_valid 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Определяет время, через которое следует проверять актуальность информации
об элементе в
<a href="#open_file_cache">open_file_cache</a>.

</p><a name="optimize_server_names"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>optimize_server_names</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>optimize_server_names off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Директива устарела, вместо неё следует использовать директиву
<a href="#server_name_in_redirect">server_name_in_redirect</a>.
</p><a name="port_in_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>port_in_redirect</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>port_in_redirect on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает указывать порт в перенаправлениях, выдаваемых nginx’ом.
</p><p>
Использование в перенаправлениях основного имени сервера управляется
директивой <a href="#server_name_in_redirect">server_name_in_redirect</a>.
</p><a name="postpone_output"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>postpone_output</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>postpone_output 1460;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Если это возможно, то отправка данных клиенту будет отложена пока nginx не
накопит по крайней мере указанное количество байт для отправки.
Значение 0 запрещает отложенную отправку данных.
</p><a name="read_ahead"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>read_ahead</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>read_ahead 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт ядру размер предчтения при работе с файлами.
</p><p>
На Linux используется системный вызов
<code>posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)</code>,
поэтому параметр <code><i>размер</i></code> там игнорируется.
</p><p>
На FreeBSD используется системный вызов
<code>fcntl(O_READAHEAD,
</code><code><i>размер</i></code><code>)</code>,
появившийся во FreeBSD 9.0-CURRENT.
Для FreeBSD 7 необходимо установить
<a href="http://sysoev.ru/freebsd/patch.readahead.txt">патч</a>.
</p><a name="recursive_error_pages"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>recursive_error_pages</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>recursive_error_pages off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает делать несколько перенаправлений через директиву
<a href="#error_page">error_page</a>.
Число таких перенаправлений <a href="#internal">ограничено</a>.
</p><a name="request_pool_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>request_pool_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>request_pool_size 4k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Позволяет производить точную настройку выделений памяти
под конкретные запросы.
Эта директива не оказывает существенного влияния на
производительность и её не следует использовать.
</p><a name="reset_timedout_connection"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>reset_timedout_connection</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>reset_timedout_connection off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает сброс соединений по таймауту.
Сброс делается следующим образом — перед закрытием сокета для него
ставится параметр
<code>SO_LINGER</code>
с таймаутом 0.
После чего при закрытии сокета клиенту отсылается TCP RST, а вся память,
связанная с этим сокетом, освобождается.
Это позволяет избежать длительного нахождения уже закрытого сокета в
состоянии FIN_WAIT1 с заполненными буферами.
</p><p>
Необходимо отметить, что keep-alive соединения по истечении таймаута
закрываются обычным образом.
</p><a name="resolver"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>resolver</strong> 
<code><i>адрес</i></code> ...
[<code>valid</code>=<code><i>время</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт серверы DNS, используемые для преобразования имён вышестоящих серверов
в адреса, например:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353;
</pre></blockquote><p> 
Адрес может быть указан в виде доменного имени или IP-адреса,
и необязательного порта (1.3.1, 1.2.2).
Если порт не указан, используется порт 53.
Серверы DNS опрашиваются циклически.
</p> <blockquote class="note">
До версии 1.1.7 можно было задать лишь один DNS-сервер.
Задание DNS-серверов с помощью IPv6-адресов поддерживается
начиная с версий 1.3.1 и 1.2.2.
</blockquote><p> 
По умолчанию nginx кэширует ответы, используя значение TTL из ответа.
Необязательный параметр <code>valid</code> позволяет это
переопределить:
</p> <blockquote class="example"><pre>
resolver 127.0.0.1 [::1]:5353 valid=30s;
</pre></blockquote><p> 
</p> <blockquote class="note">
До версии 1.1.9 настройка времени кэширования была невозможна
и nginx всегда кэшировал ответы на срок в 5 минут.
</blockquote><p> 
</p><a name="resolver_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>resolver_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>resolver_timeout 30s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут для преобразования имени в адрес, например:
</p> <blockquote class="example"><pre>
resolver_timeout 5s;
</pre></blockquote><p> 
</p><a name="root"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>root</strong> <code><i>путь</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>root html;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт корневой каталог для запросов.
Например, при такой конфигурации
</p> <blockquote class="example"><pre>
location /i/ {
    root /data/w3;
}
</pre></blockquote><p> 
в ответ на запрос “<code>/i/top.gif</code>” будет отдан файл
<code>/data/w3/i/top.gif</code>.
</p><p>
В значении параметра <code><i>путь</i></code> можно использовать переменные,
кроме <code>$document_root</code> и <code>$realpath_root</code>.
</p><p>
Путь к файлу формируется путём простого добавления URI к значению директивы
<code>root</code>.
Если же URI необходимо поменять, следует воспользоваться директивой
<a href="#alias">alias</a>.
</p><a name="satisfy"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>satisfy</strong> <code>all</code> | <code>any</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>satisfy all;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает доступ, если оба (<code>all</code>)
или хотя бы один (<code>any</code>) из модулей
<a href="ngx_http_access_module.html">ngx_http_access_module</a>
и <a href="ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>
разрешают доступ.
</p><p>
Пример:
</p> <blockquote class="example"><pre>
location / {
    satisfy any;

    allow 192.168.1.0/32;
    deny  all;

    auth_basic           "closed site";
    auth_basic_user_file conf/htpasswd;
}
</pre></blockquote><p> 
</p><a name="satisfy_any"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>satisfy_any</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>satisfy_any off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Эта директива была заменена параметром <code>any</code>
директивы <a href="#satisfy">satisfy</a>.
</p><a name="send_lowat"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>send_lowat</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>send_lowat 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
При установке в ненулевое значение nginx будет пытаться минимизировать
число операций отправки на клиентских сокетах либо при помощи флага
<code>NOTE_LOWAT</code> метода
<a href="../events.html#kqueue">kqueue</a>,
либо при помощи параметра сокета <code>SO_SNDLOWAT</code>,
с указанным размером.
</p><p>
Эта директива игнорируется на Linux, Solaris и Windows.
</p><a name="send_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>send_timeout</strong> <code><i>время</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>send_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт таймаут при передаче ответа клиенту.
Таймаут устанавливается не на всю передачу ответа,
а только между двумя операциями записями.
Если по истечении этого времени клиент ничего не примет,
соединение будет закрыто.
</p><a name="sendfile"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>sendfile</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>sendfile off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code>, <code>if в location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использовать
<code>sendfile()</code>.
</p><a name="sendfile_max_chunk"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>sendfile_max_chunk</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>sendfile_max_chunk 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
При установке в ненулевое значение ограничивает объём данных,
который может передан за один вызов <code>sendfile()</code>.
Без этого ограничения одно быстрое соединение может целиком
захватить рабочий процесс.
</p><a name="server"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт конфигурацию для виртуального сервера.
Чёткого разделения виртуальных серверов на IP-based (на основании IP-адреса)
и name-based (на основании поля “Host” заголовка запроса) нет.
Вместо этого директивами <a href="#listen">listen</a> описываются все
адреса и порты, на которых нужно принимать соединения для этого сервера,
а в директиве <a href="#server_name">server_name</a> указываются все имена серверов.
Примеры конфигураций описаны в документе
“<a href="request_processing.html">Как nginx обрабатывает запросы</a>”.
</p><a name="server_name"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server_name</strong> <code><i>имя</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>server_name "";</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт имена виртуального сервера, например:
</p> <blockquote class="example"><pre>
server {
    server_name example.com www.example.com;
}
</pre></blockquote><p> 
</p><p>
Первое имя становится основным именем сервера.
</p><p>
В именах серверов можно использовать звёздочку (“<code>*</code>”)
для замены первой или последней части имени:
</p> <blockquote class="example"><pre>
server {
    server_name example.com *.example.com www.example.*;
}
</pre></blockquote><p> 
Такие имена называются именами с маской.
</p><p>
Два первых вышеприведённых имени можно объединить в одно:
</p> <blockquote class="example"><pre>
server {
    server_name .example.com;
}
</pre></blockquote><p> 
</p><p>
В качестве имени сервера можно также использовать регулярное выражение,
указав перед ним тильду (“<code>~</code>”):
</p> <blockquote class="example"><pre>
server {
    server_name www.example.com ~^www\d+\.example\.com$;
}
</pre></blockquote><p> 
</p><p>
Регулярное выражение может содержать выделения (0.7.40),
которые могут затем использоваться в других директивах:
</p> <blockquote class="example"><pre>
server {
    server_name ~^(www\.)?(.+)$;

    location / {
        root /sites/$2;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre></blockquote><p> 
</p><p>
Именованные выделения в регулярном выражении создают переменные (0.8.25),
которые могут затем использоваться в других директивах:
</p> <blockquote class="example"><pre>
server {
    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;

    location / {
        root /sites/$domain;
    }
}

server {
    server_name _;

    location / {
        root /sites/default;
    }
}
</pre></blockquote><p> 
</p><p>
Если параметр равен “<code>$hostname</code>” (0.9.4), то
подставляется имя хоста (hostname) машины.
</p><p>
Возможно также указать пустое имя сервера (0.7.11):
</p> <blockquote class="example"><pre>
server {
    server_name www.example.com "";
}
</pre></blockquote><p> 
Это позволяет обрабатывать запросы без поля “Host” заголовка
запроса в этом сервере, а не в сервере по умолчанию для данной пары адрес:порт.
Это настройка по умолчанию.
</p> <blockquote class="note">
До 0.8.48 по умолчанию использовалось имя хоста (hostname) машины.
</blockquote><p> 
</p><p>
При поиске виртуального сервера по имени,
если имени соответствует несколько из указанных вариантов,
например, одновременно подходят и имя с маской, и регулярное выражение,
будет выбран первый подходящий вариант в следующем порядке приоритета:
</p> <ol class="compact">

<li>
точное имя
</li>

<li>
самое длинное имя с маской в начале,
например “<code>*.example.com</code>”
</li>

<li>
самое длинное имя с маской в конце,
например “<code>mail.*</code>”
</li>

<li>
первое подходящее регулярное выражение
(в порядке следования в конфигурационном файле)
</li>

</ol><p> 
</p><p>
Подробнее имена серверов обсуждаются в отдельном
<a href="server_names.html">документе</a>.
</p><a name="server_name_in_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server_name_in_redirect</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>server_name_in_redirect off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использовать в перенаправлениях, выдаваемых nginx’ом,
основное имя сервера, задаваемое директивой
<a href="#server_name">server_name</a>.
Если запрещено, то используется имя, указанное в поле “Host”
заголовка запроса.
Если же этого поля нет, то используется IP-адрес сервера.
</p><p>
Использование в перенаправлениях порта управляется
директивой <a href="#port_in_redirect">port_in_redirect</a>.
</p><a name="server_names_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server_names_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>server_names_hash_bucket_size 32|64|128;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблицах имён серверов.
Значение по умолчанию зависит от размера строки кэша процессора.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="server_names_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server_names_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>server_names_hash_max_size 512;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблиц имён серверов.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="server_tokens"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>server_tokens</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>server_tokens on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает выдавать версию nginx’а в сообщениях об ошибках и
в поле “Server” заголовка ответа.
</p><a name="tcp_nodelay"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>tcp_nodelay</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>tcp_nodelay on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование параметра <code>TCP_NODELAY</code>.
Параметр включаются только при переходе соединения в состояние keep-alive.
</p><a name="tcp_nopush"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>tcp_nopush</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>tcp_nopush off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование параметра сокета
<code>TCP_NOPUSH</code> во FreeBSD или
<code>TCP_CORK</code> в Linux.
Параметр включаются только при использовании <a href="#sendfile">sendfile</a>.
Включение параметра  позволяет
</p> <ul class="compact">

<li>
передавать заголовок ответа и начало файла в одном пакете
в Linux и во FreeBSD 4.*;
</li>

<li>
передавать файл полными пакетами.
</li>

</ul><p> 
</p><a name="try_files"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>try_files</strong> <code><i>файл</i></code> ... <code><i>uri</i></code>;</code><br><code><strong>try_files</strong> <code><i>файл</i></code> ... =<code><i>код</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Проверяет существование файлов в заданном порядке и использует
для обработки запроса первый найденный файл, причём обработка
делается в контексте этого же location’а.
Путь к файлу строится из параметра <code><i>файл</i></code>
в соответствии с директивами
<a href="#root">root</a> и <a href="#alias">alias</a>.
С помощью слэша в конце имени можно проверить существование каталога,
например, “<code>$uri/</code>”.
В случае, если ни один файл не найден, то делается внутреннее
перенаправление на <code><i>uri</i></code>, заданный последним параметром.
Например:
</p> <blockquote class="example"><pre>
location /images/ {
    try_files $uri /images/default.gif;
}

location = /images/default.gif {
    expires 30s;
}
</pre></blockquote><p> 
Последний параметр может также указывать на именованный location,
как в примерах ниже.
С версии 0.7.51 последний параметр может также быть кодом:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/index.html $uri.html =404;
}
</pre></blockquote><p> 
</p><p>
Пример использования при проксировании Mongrel:
</p> <blockquote class="example"><pre>
location / {
    try_files /system/maintenance.html
              $uri $uri/index.html $uri.html
              @mongrel;
}

location @mongrel {
    proxy_pass http://mongrel;
}
</pre></blockquote><p> 
</p><p>
Пример использования вместе с Drupal/FastCGI:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @drupal;
}

location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    fastcgi_param SCRIPT_NAME     $fastcgi_script_name;
    fastcgi_param QUERY_STRING    $args;

    ... прочие fastcgi_param
}

location @drupal {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    fastcgi_param SCRIPT_NAME     /index.php;
    fastcgi_param QUERY_STRING    q=$uri&amp;$args;

    ... прочие fastcgi_param
}
</pre></blockquote><p> 
В следующем примере директива <code>try_files</code>
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @drupal;
}
</pre></blockquote><p> 
аналогична директивам
</p> <blockquote class="example"><pre>
location / {
    error_page 404 = @drupal;
    log_not_found off;
}
</pre></blockquote><p> 
А здесь
</p> <blockquote class="example"><pre>
location ~ \.php$ {
    try_files $uri @drupal;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;

    ...
}
</pre></blockquote><p> 
<code>try_files</code> проверяет существование PHP-файла,
прежде чем передать запрос FastCGI-серверу.
</p><p>
Пример использования вместе с Wordpress и Joomla:
</p> <blockquote class="example"><pre>
location / {
    try_files $uri $uri/ @wordpress;
}

location ~ \.php$ {
    try_files $uri @wordpress;

    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;
    ... прочие fastcgi_param
}

location @wordpress {
    fastcgi_pass ...;

    fastcgi_param SCRIPT_FILENAME /path/to/index.php;
    ... прочие fastcgi_param
}
</pre></blockquote><p> 
</p><a name="types"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>types</strong> { ... }</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>types {
    text/html  html;
    image/gif  gif;
    image/jpeg jpg;
}</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт соответствие расширений имён файлов и MIME-типов ответов.
Расширения нечувствительны к регистру символов.
Одному MIME-типу может соответствовать несколько расширений, например:
</p> <blockquote class="example"><pre>
types {
    application/octet-stream bin exe dll;
    application/octet-stream deb;
    application/octet-stream dmg;
}
</pre></blockquote><p> 
</p><p>
Достаточно полная таблица соответствий входит в дистрибутив nginx
и находится в файле <code>conf/mime.types</code>.
</p><p>
Для того, чтобы для определённого location’а для всех ответов
выдавался MIME-тип “<code>application/octet-stream</code>”,
можно использовать следующее:
</p> <blockquote class="example"><pre>
location /download/ {
    types        { }
    default_type application/octet-stream;
}
</pre></blockquote><p> 
</p><a name="types_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>types_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>types_hash_bucket_size 32|64|128;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблицах типов.
Значение по умолчанию зависит от размера строки кэша процессора.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="types_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>types_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>types_hash_max_size 1024;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблиц типов.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="underscores_in_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>underscores_in_headers</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>underscores_in_headers off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code>, <code>server</code><br>
                </td>
                </tr>
            </table></div><p>
Разрешает или запрещает использование символов подчёркивания в
полях заголовка запроса клиента.
Если запрещено, поля заголовка запроса, в чьих именах есть подчёркивания,
помечаются как недопустимые и подпадают под действие директивы
<a href="#ignore_invalid_headers">ignore_invalid_headers</a>.
</p><p>
Директива может быть указана на уровне <a href="#server">server</a>
в сервере по умолчанию.
В этом случае её значение распространяется на все виртуальные серверы,
слушающие на том же адресе и порту.
</p><a name="variables_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>variables_hash_bucket_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>variables_hash_bucket_size 64;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт размер корзины в хэш-таблице переменных.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p><a name="variables_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            синтаксис:
                </td>
                <td>
            <code><strong>variables_hash_max_size</strong> <code><i>размер</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            умолчание:
                </td>
                <td>
            <pre>variables_hash_max_size 512;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            контекст:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Задаёт максимальный <code><i>размер</i></code> хэш-таблицы переменных.
Подробнее настройка хэш-таблиц обсуждается в отдельном
<a href="../hash.html">документе</a>.
</p>


<a name="variables"></a><center><h4>Встроенные переменные</h4></center><p>
Модуль <code>ngx_http_core_module</code> поддерживает встроенные
переменные, имена которых совпадают с именами переменных веб-сервера Apache.
Прежде всего, это переменные, представляющие из себя поля заголовка
запроса клиента, такие как <code>$http_user_agent</code>, <code>$http_cookie</code>
и тому подобное.
Кроме того, есть и другие переменные:
</p> <dl class="compact">

<dt id="var_arg_"><code>$arg_</code><code><i>имя</i></code></dt>
<dd>
аргумент <code><i>имя</i></code> в строке запроса
</dd>

<dt id="var_args"><code>$args</code></dt>
<dd>
аргументы в строке запроса
</dd>

<dt id="var_binary_remote_addr"><code>$binary_remote_addr</code></dt>
<dd>
адрес клиента в бинарном виде, длина значения всегда 4 байта
</dd>

<dt id="var_body_bytes_sent"><code>$body_bytes_sent</code></dt>
<dd>
число байт, переданное клиенту, без учёта заголовка ответа;
переменная совместима с параметром “<code>%B</code>” модуля Apache
<code>mod_log_config</code>
</dd>

<dt id="var_bytes_sent"><code>$bytes_sent</code></dt>
<dd>
число байт, переданное клиенту (1.3.8, 1.2.5)
</dd>

<dt id="var_connection"><code>$connection</code></dt>
<dd>
порядковый номер соединения (1.3.8, 1.2.5)
</dd>

<dt id="var_connection_requests"><code>$connection_requests</code></dt>
<dd>
текущее число запросов в соединении (1.3.8, 1.2.5)
</dd>

<dt id="var_content_length"><code>$content_length</code></dt>
<dd>
поле “Content-Length” заголовка запроса
</dd>

<dt id="var_content_type"><code>$content_type</code></dt>
<dd>
поле “Content-Type” заголовка запроса
</dd>

<dt id="var_cookie_"><code>$cookie_</code><code><i>имя</i></code></dt>
<dd>
cookie <code><i>имя</i></code>
</dd>

<dt id="var_document_root"><code>$document_root</code></dt>
<dd>
значение директивы <a href="#root">root</a> или <a href="#alias">alias</a>
для текущего запроса
</dd>

<dt id="var_document_uri"><code>$document_uri</code></dt>
<dd>
то же, что и <code>$uri</code>
</dd>

<dt id="var_host"><code>$host</code></dt>
<dd>
поле “Host” заголовка запроса,
или имя сервера, соответствующего запросу, если этого поля нет
</dd>

<dt id="var_hostname"><code>$hostname</code></dt>
<dd>
имя хоста
</dd>

<dt id="var_http_"><code>$http_</code><code><i>имя</i></code></dt>
<dd>
произвольное поле заголовка запроса;
последняя часть имени переменной соответствует имени поля, приведённому
к нижнему регистру, с заменой символов тире на символы подчёркивания
</dd>

<dt id="var_https"><code>$https</code></dt>
<dd>
“<code>on</code>”
если соединение работает в режиме SSL,
либо пустая строка
</dd>

<dt id="var_is_args"><code>$is_args</code></dt>
<dd>
“<code>?</code>”, если в строке запроса есть аргументы,
и пустая строка, если их нет
</dd>

<dt id="var_limit_rate"><code>$limit_rate</code></dt>
<dd>
установка этой переменной позволяет ограничивать скорость
передачи ответа, см. <a href="#limit_rate">limit_rate</a>
</dd>

<dt id="var_msec"><code>$msec</code></dt>
<dd>
текущее время в секундах с точностью до миллисекунд (1.3.9, 1.2.6)
</dd>

<dt id="var_nginx_version"><code>$nginx_version</code></dt>
<dd>
версия nginx
</dd>

<dt id="var_pid"><code>$pid</code></dt>
<dd>
номер (PID) рабочего процесса
</dd>

<dt id="var_query_string"><code>$query_string</code></dt>
<dd>
то же, что и <code>$args</code>
</dd>

<dt id="var_realpath_root"><code>$realpath_root</code></dt>
<dd>
абсолютный путь, соответствующий
значению директивы <a href="#root">root</a> или <a href="#alias">alias</a>
для текущего запроса,
в котором все символические ссылки преобразованы в реальные пути
</dd>

<dt id="var_remote_addr"><code>$remote_addr</code></dt>
<dd>
адрес клиента
</dd>

<dt id="var_remote_port"><code>$remote_port</code></dt>
<dd>
порт клиента
</dd>

<dt id="var_remote_user"><code>$remote_user</code></dt>
<dd>
имя пользователя, использованное в Basic аутентификации
</dd>

<dt id="var_request"><code>$request</code></dt>
<dd>
первоначальная строка запроса целиком
</dd>

<dt id="var_request_body"><code>$request_body</code></dt>
<dd>
тело запроса
<p>
Значение переменной появляется в location’ах, обрабатываемых
директивами
<a href="ngx_http_proxy_module.html#proxy_pass">proxy_pass</a>
и
<a href="ngx_http_fastcgi_module.html#fastcgi_pass">fastcgi_pass</a>.
</p>
</dd>

<dt id="var_request_body_file"><code>$request_body_file</code></dt>
<dd>
имя временного файла, в котором хранится тело запроса
<p>
По завершению обработки файл необходимо удалить.
Для того, чтобы тело запроса всегда записывалось в файл,
следует включить <a href="#client_body_in_file_only">client_body_in_file_only</a>.
При передаче имени временного файла в проксированном запросе
или в запросе к FastCGI-серверу следует запретить передачу самого
тела директивами
<a href="ngx_http_proxy_module.html#proxy_pass_request_body">
proxy_pass_request_body off</a>
или
<a href="ngx_http_fastcgi_module.html#fastcgi_pass_request_body">
fastcgi_pass_request_body off</a>
соответственно.
</p>
</dd>

<dt id="var_request_completion"><code>$request_completion</code></dt>
<dd>
“<code>OK</code>” если запрос завершился,
либо пустая строка
</dd>

<dt id="var_request_filename"><code>$request_filename</code></dt>
<dd>
путь к файлу для текущего запроса, формируемый из директив
<a href="#root">root</a> или <a href="#alias">alias</a> и URI запроса
</dd>

<dt id="var_request_method"><code>$request_method</code></dt>
<dd>
метод запроса, обычно
“<code>GET</code>” или “<code>POST</code>”
</dd>

<dt id="var_request_time"><code>$request_time</code></dt>
<dd>
время обработки запроса в секундах с точностью до миллисекунд
(1.3.9, 1.2.6);
время, прошедшее с момента чтения первых байт от клиента
</dd>

<dt id="var_request_uri"><code>$request_uri</code></dt>
<dd>
первоначальный URI запроса целиком (с аргументами)
</dd>

<dt id="var_scheme"><code>$scheme</code></dt>
<dd>
схема запроса, “<code>http</code>” или “<code>https</code>”
</dd>

<dt id="var_sent_http_"><code>$sent_http_</code><code><i>имя</i></code></dt>
<dd>
произвольное поле заголовка ответа;
последняя часть имени переменной соответствует имени поля, приведённому
к нижнему регистру, с заменой символов тире на символы подчёркивания
</dd>

<dt id="var_server_addr"><code>$server_addr</code></dt>
<dd>
адрес сервера, принявшего запрос
<p>
Получение значения этой переменной обычно требует одного системного вызова.
Чтобы избежать системного вызова, в директивах <a href="#listen">listen</a>
следует указывать адреса и использовать параметр <code>bind</code>.
</p>
</dd>

<dt id="var_server_name"><code>$server_name</code></dt>
<dd>
имя сервера, принявшего запрос
</dd>

<dt id="var_server_port"><code>$server_port</code></dt>
<dd>
порт сервера, принявшего запрос
</dd>

<dt id="var_server_protocol"><code>$server_protocol</code></dt>
<dd>
протокол сервера, обычно
“<code>HTTP/1.0</code>”
или
“<code>HTTP/1.1</code>”
</dd>

<dt id="var_status"><code>$status</code></dt>
<dd>
статус ответа (1.3.2, 1.2.2)
</dd>

<dt id="var_tcpinfo_">
<code>$tcpinfo_rtt</code>,
<code>$tcpinfo_rttvar</code>,
<code>$tcpinfo_snd_cwnd</code>,
<code>$tcpinfo_rcv_space</code>
</dt>
<dd>
информация о клиентском TCP-соединении; доступна на системах,
поддерживающих параметр сокета <code>TCP_INFO</code>
</dd>

<dt id="var_uri"><code>$uri</code></dt>
<dd>
текущий URI запроса в <a href="#location">нормализованном</a> виде
<p>
Значение <code>$uri</code> может изменяться в процессе обработки запроса,
например, при внутренних перенаправлениях
или при использовании индексных файлов.
</p>
</dd>

</dl><p> 
</p>

</td></tr></table></body></html>
