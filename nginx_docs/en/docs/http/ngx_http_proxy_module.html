<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Module ngx_http_proxy_module</title><style type="text/css">body { font-family: Georgia, serif; } p { text-align: justify; } table.news p { margin-top: 0; } table.news td { vertical-align: baseline; } table.news .date { text-align: right; padding-right: 0.5em; white-space: nowrap; } table.donors td { vertical-align: baseline; } table.donors li { text-align: left; } div.directive { background: #EEEEEE; padding: 10pt 10pt 10pt 0; } div.directive td { vertical-align: baseline; } div.directive pre { padding: 0; margin: 0; } div.directive p { margin: 5pt 0 0 0; font-size: 80%; } div#banner { background: #EEEEEE; padding: 10pt 10pt 10pt 0; } a.notrans { color: gray; text-decoration:none; } span.initial { font-size: 200%; float: left; padding-right: 10pt;} li { text-align: justify; padding-top: 0.5em; } .compact li { padding-top: 0; } dt { padding-top: 0.5em; } .compact dt { padding-top: 0; } dd { text-align: justify; } td.list { background: #EEEEEE; } blockquote.note { text-align: justify; background: #EEEEEE; border: none; margin: 1em; padding: 0.5em; } blockquote.example { background: transparent; border: none; margin: 1em; padding: 0.5em; } blockquote.example pre { padding: 0; margin: 0; } sup { font-size: 50%; }</style><script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-27974099-2']);
        _gaq.push(['_setDomainName', 'nginx.org']);
        _gaq.push(['_trackPageview']);

        (function() {
           var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
           ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
           var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script></head><body><table width="100%"><tr><td width="70%"><div id="banner"><center><table><tr><td align="center"><a href="http://nginx.com/support.html"><strong>nginx professional services</strong></a></td></tr><tr><td align="center"><i>Prioritize. Save time. Stay focused.</i></td></tr></table></center></div></td><td align="right"><a href="http://nginx.org"><img src="http://nginx.org/nginx.gif" alt="nginx" border="0"></a></td></tr><tr><td width="70%"><center><h3>Module ngx_http_proxy_module</h3></center></td><td rowspan="2" align="right" valign="top"><br>english<br><a href="../../../ru/docs/http/ngx_http_proxy_module.html">русский</a><br><br><a href="../../../cn/docs/http/ngx_http_proxy_module.html">简体中文</a><br><a class="notrans">עברית</a><br><a class="notrans">日本語</a><br><a class="notrans">türkçe</a><br><br><a href="../../../">news</a><br><a href="../../../en/">about</a><br><a href="../../../en/download.html">download</a><br><a href="../../../en/security_advisories.html">security advisories</a><br><a href="../../../en/docs/">documentation</a><br><a href="../../../en/pgp_keys.html">pgp keys</a><br><a href="../../../en/docs/faq.html">faq</a><br><a href="../../../en/links.html">links</a><br><a href="../../../en/books.html">books</a><br><a href="../../../en/support.html">support</a><br><a href="../../../en/donation.html">donation</a><br><br><a href="http://trac.nginx.org/nginx">trac</a><br><a href="http://wiki.nginx.org/">wiki</a><br><a href="http://twitter.com/nginxorg">twitter</a><br><a href="http://www.nginx.com/">nginx.com</a><br></td></tr><tr><td valign="top"><table width="100%"><tr><td align="left"><a href="#example">Example Configuration</a><br><a href="#directives">Directives</a><br>     <a href="#proxy_bind">proxy_bind</a><br>     <a href="#proxy_buffer_size">proxy_buffer_size</a><br>     <a href="#proxy_buffering">proxy_buffering</a><br>     <a href="#proxy_buffers">proxy_buffers</a><br>     <a href="#proxy_busy_buffers_size">proxy_busy_buffers_size</a><br>     <a href="#proxy_cache">proxy_cache</a><br>     <a href="#proxy_cache_bypass">proxy_cache_bypass</a><br>     <a href="#proxy_cache_key">proxy_cache_key</a><br>     <a href="#proxy_cache_lock">proxy_cache_lock</a><br>     <a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a><br>     <a href="#proxy_cache_methods">proxy_cache_methods</a><br>     <a href="#proxy_cache_min_uses">proxy_cache_min_uses</a><br>     <a href="#proxy_cache_path">proxy_cache_path</a><br>     <a href="#proxy_cache_use_stale">proxy_cache_use_stale</a><br>     <a href="#proxy_cache_valid">proxy_cache_valid</a><br>     <a href="#proxy_connect_timeout">proxy_connect_timeout</a><br>     <a href="#proxy_cookie_domain">proxy_cookie_domain</a><br>     <a href="#proxy_cookie_path">proxy_cookie_path</a><br>     <a href="#proxy_headers_hash_bucket_size">proxy_headers_hash_bucket_size</a><br>     <a href="#proxy_headers_hash_max_size">proxy_headers_hash_max_size</a><br>     <a href="#proxy_hide_header">proxy_hide_header</a><br>     <a href="#proxy_http_version">proxy_http_version</a><br>     <a href="#proxy_ignore_client_abort">proxy_ignore_client_abort</a><br>     <a href="#proxy_ignore_headers">proxy_ignore_headers</a><br>     <a href="#proxy_intercept_errors">proxy_intercept_errors</a><br>     <a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a><br>     <a href="#proxy_method">proxy_method</a><br>     <a href="#proxy_next_upstream">proxy_next_upstream</a><br>     <a href="#proxy_no_cache">proxy_no_cache</a><br>     <a href="#proxy_pass">proxy_pass</a><br>     <a href="#proxy_pass_header">proxy_pass_header</a><br>     <a href="#proxy_read_timeout">proxy_read_timeout</a><br>     <a href="#proxy_pass_request_body">proxy_pass_request_body</a><br>     <a href="#proxy_pass_request_headers">proxy_pass_request_headers</a><br>     <a href="#proxy_redirect">proxy_redirect</a><br>     <a href="#proxy_send_lowat">proxy_send_lowat</a><br>     <a href="#proxy_send_timeout">proxy_send_timeout</a><br>     <a href="#proxy_set_body">proxy_set_body</a><br>     <a href="#proxy_set_header">proxy_set_header</a><br>     <a href="#proxy_ssl_session_reuse">proxy_ssl_session_reuse</a><br>     <a href="#proxy_store">proxy_store</a><br>     <a href="#proxy_store_access">proxy_store_access</a><br>     <a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a><br>     <a href="#proxy_temp_path">proxy_temp_path</a><br><a href="#variables">Embedded Variables</a><br></td></tr></table>

<a name="summary"></a><p>
The <code>ngx_http_proxy_module</code> module allows to pass
requests to another server.
</p>


<a name="example"></a><center><h4>Example Configuration</h4></center><p>
</p> <blockquote class="example"><pre>
location / {
    proxy_pass       http://localhost:8000;
    proxy_set_header Host      $host;
    proxy_set_header X-Real-IP $remote_addr;
}
</pre></blockquote><p> 
</p>


<a name="directives"></a><center><h4>Directives</h4></center><a name="proxy_bind"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_bind</strong> <code><i>address</i></code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 0.8.22.

            </p></div><p>
Forces outgoing connections to a proxied server to originate
from the specified local IP <code><i>address</i></code>.
Value of the parameter can contain variables (1.3.12).
The special value <code>off</code> (1.3.12) cancels the effect
of the <code>proxy_bind</code> directive
inherited from the previous configuration level, allowing the
system to auto-assign local address.
</p><a name="proxy_buffer_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_buffer_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_buffer_size 4k|8k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets <code><i>size</i></code> of the buffer used for reading the first part
of a response received from the proxied server.
This part usually contains a small response header.
By default, the buffer size is equal to the size of one
buffer set by the <a href="#proxy_buffers">proxy_buffers</a> directive.
It can be made smaller however.
</p><a name="proxy_buffering"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_buffering</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_buffering on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Enables or disables buffering of responses from the proxied server.
</p><p>
When buffering is enabled, nginx receives a response from the proxied server
as soon as possible, saving it into buffers set by the
<a href="#proxy_buffer_size">proxy_buffer_size</a> and <a href="#proxy_buffers">proxy_buffers</a> directives.
If the whole response does not fit into memory, part of it can be saved
to a <a href="#proxy_temp_path">temporary file</a> on disk.
Writes to temporary files are controlled by the
<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a> and
<a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a> directives.
</p><p>
When buffering is disabled, a response is passed to a client synchronously,
immediately as it is received.
nginx will not try to read the whole response from the proxied server.
The maximum size of the data that nginx can receive from the server
at a time is set by the <a href="#proxy_buffer_size">proxy_buffer_size</a> directive.
</p><p>
Buffering can also be enabled or disabled by passing
“<code>yes</code>” or “<code>no</code>” in the
“X-Accel-Buffering” response header field.
This ability can be disabled using the
<a href="ngx_http_proxy_module.html#proxy_ignore_headers">proxy_ignore_headers</a> directive.
</p><a name="proxy_buffers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_buffers</strong> <code><i>number</i></code> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_buffers 8 4k|8k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets the <code><i>number</i></code> and <code><i>size</i></code> of
buffers used for reading a response from the proxied server,
for a single connection.
By default, the buffer size is equal to one memory page.
This is either 4K or 8K, depending on a platform.
</p><a name="proxy_busy_buffers_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_busy_buffers_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_busy_buffers_size 8k|16k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
When <a href="#proxy_buffering">buffering</a> of responses from the proxied
server is enabled, limits the total <code><i>size</i></code> of buffers that
can be busy sending a response to the client while the response is not
yet fully read.
In the mean time, the rest of the buffers can be used for reading a response
and, if needed, buffering part of a response to a temporary file.
By default, <code><i>size</i></code> is limited by two buffers set by the
<a href="#proxy_buffer_size">proxy_buffer_size</a> and <a href="#proxy_buffers">proxy_buffers</a> directives.
</p><a name="proxy_cache"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache</strong> <code><i>zone</i></code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines a shared memory zone used for caching.
The same zone can be used in several places.
The <code>off</code> parameter disables caching inherited
from the previous configuration level.
</p><a name="proxy_cache_bypass"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_bypass</strong> <code><i>string</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines conditions under which the response will not be taken from a cache.
If at least one value of the string parameters is not empty and is not
equal to “0” then the response will not be taken from the cache:
</p> <blockquote class="example"><pre>
proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
proxy_cache_bypass $http_pragma    $http_authorization;
</pre></blockquote><p> 
Can be used along with the <a href="#proxy_no_cache">proxy_no_cache</a> directive.
</p><a name="proxy_cache_key"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_key</strong> <code><i>string</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_key $scheme$proxy_host$request_uri;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines a key for caching, for example
</p> <blockquote class="example"><pre>
proxy_cache_key "$host$request_uri $cookie_user";
</pre></blockquote><p> 
By default, the directive’s value is close to the string
</p> <blockquote class="example"><pre>
proxy_cache_key $scheme$proxy_host$uri$is_args$args;
</pre></blockquote><p> 
</p><a name="proxy_cache_lock"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_lock</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_lock off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 1.1.12.

            </p></div><p>
When enabled, only one request at a time will be allowed to populate
a new cache element identified according to the <a href="#proxy_cache_key">proxy_cache_key</a>
directive by passing a request to a proxied server.
Other requests of the same cache element will either wait
for a response to appear in the cache, or the cache lock for
this element to be released, up to the time set by the
<a href="#proxy_cache_lock_timeout">proxy_cache_lock_timeout</a> directive.
</p><a name="proxy_cache_lock_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_lock_timeout</strong> <code><i>time</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_lock_timeout 5s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 1.1.12.

            </p></div><p>
Sets a timeout for <a href="#proxy_cache_lock">proxy_cache_lock</a>.
</p><a name="proxy_cache_methods"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_methods</strong> 
    <code>GET</code> |
    <code>HEAD</code> |
    <code>POST</code>
    ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_methods GET HEAD;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 0.7.59.

            </p></div><p>
If the client request method is listed in this directive then
the response will be cached.
“<code>GET</code>” and “<code>HEAD</code>” methods are always
added to the list, though it is recommended to specify them explicitly.
See also the <a href="#proxy_no_cache">proxy_no_cache</a> directive.
</p><a name="proxy_cache_min_uses"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_min_uses</strong> <code><i>number</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_min_uses 1;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets the <code><i>number</i></code> of requests after which the response
will be cached.
</p><a name="proxy_cache_path"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_path</strong> 
    <code><i>path</i></code>
    [<code>levels</code>=<code><i>levels</i></code>]
    <code>keys_zone</code>=<code><i>name</i></code>:<code><i>size</i></code>
    [<code>inactive</code>=<code><i>time</i></code>]
    [<code>max_size</code>=<code><i>size</i></code>]
    [<code>loader_files</code>=<code><i>number</i></code>]
    [<code>loader_sleep</code>=<code><i>time</i></code>]
    [<code>loader_threshold</code>=<code><i>time</i></code>];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code><br>
                </td>
                </tr>
            </table></div><p>
Sets path and other parameters of a cache.
Cache data are stored in files.
Both the key and file name in a cache are a result of
applying the MD5 function to the proxied URL.

The <code>levels</code> parameter defines hierarchy levels of a cache.
For example, in the following configuration
</p> <blockquote class="example"><pre>
proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</pre></blockquote><p> 
file names in a cache will look like this:
</p> <blockquote class="example"><pre>
/data/nginx/cache/<strong>c</strong>/<strong>29</strong>/b7f54b2df7773722d382f4809d650<strong>29c</strong>
</pre></blockquote><p> 
</p><p>
A cached response is first written to a temporary file, then a file is renamed.
Starting from version 0.8.9 temporary files and the cache can be put on
different file systems but be aware that in this case a file is copied
across two file systems instead of the cheap rename operation.
It is thus recommended that for any given location both cache and a directory
holding temporary files set by the <a href="#proxy_temp_path">proxy_temp_path</a> directive
are put on the same file system.
</p><p>
In addition, all active keys and information about data are stored
in a shared memory zone, whose <code><i>name</i></code> and <code><i>size</i></code>
are configured by the <code>keys_zone</code> parameter.
Cached data that are not accessed during the time specified by the
<code>inactive</code> parameter get removed from the cache
regardless of their freshness.
By default, <code>inactive</code> is set to 10 minutes.
</p><p>
The special process “cache manager” monitors the maximum cache size set
by the <code>max_size</code> parameter;
when this size is exceeded it removes the least recently used data.
</p><p>
A minute after the start the special process “cache loader” is activated
that loads information about previously cached data stored on file system
into a cache zone.
A load is done in iterations.
During one iteration no more than <code>loader_files</code> items
are loaded (by default, 100).
Besides, the duration of one iteration is limited by the
<code>loader_threshold</code> parameter (by default, 200 milliseconds).
A pause is made between iterations, configured by the
<code>loader_sleep</code> parameter (by default, 50 milliseconds).
</p><a name="proxy_cache_use_stale"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_use_stale</strong> 
    <code>error</code> |
    <code>timeout</code> |
    <code>invalid_header</code> |
    <code>updating</code> |
    <code>http_500</code> |
    <code>http_502</code> |
    <code>http_503</code> |
    <code>http_504</code> |
    <code>http_404</code> |
    <code>off</code>
    ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cache_use_stale off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
If an error occurs while working with the proxied server it is possible
to use a stale cached response.
This directives determines in which cases it is permitted.
The directive’s parameters match those of the
<a href="#proxy_next_upstream">proxy_next_upstream</a> directive.
</p><p>
Additionally, the <code>updating</code> parameter permits
to use a stale cached response if it is currently being updated.
This allows to minimize the number of accesses to proxied servers
when updating cached data.
</p><p>
To minimize the number of accesses to proxied servers when
populating a new cache element, the <a href="#proxy_cache_lock">proxy_cache_lock</a>
directive can be used.
</p><a name="proxy_cache_valid"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cache_valid</strong> [<code><i>code</i></code> ...] <code><i>time</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets caching time for different response codes.
For example, the following directives
</p> <blockquote class="example"><pre>
proxy_cache_valid 200 302 10m;
proxy_cache_valid 404      1m;
</pre></blockquote><p> 
set 10 minutes of caching for responses with codes 200 and 302,
and 1 minute for responses with code 404.
</p><p>
If only caching <code><i>time</i></code> is specified
</p> <blockquote class="example"><pre>
proxy_cache_valid 5m;
</pre></blockquote><p> 
then only 200, 301, and 302 responses are cached.
</p><p>
In addition, it can be specified to cache any responses using the
<code>any</code> parameter:
</p> <blockquote class="example"><pre>
proxy_cache_valid 200 302 10m;
proxy_cache_valid 301      1h;
proxy_cache_valid any      1m;
</pre></blockquote><p> 
</p><p>
Parameters of caching can also be set directly
in the response header.
This has a higher precedence than setting of caching time using the directive.
The “X-Accel-Expires” header field sets caching time of a
response in seconds.
The value 0 disables to cache a response.
If a value starts with the prefix <code>@</code>, it sets an absolute
time in seconds since Epoch, up to which the response may be cached.
If header does not include the “X-Accel-Expires” field,
parameters of caching may be set in the header fields
“Expires” or “Cache-Control”.
If a header includes the “Set-Cookie” field, such a
response will not be cached.
Processing of one or more of these response header fields can be disabled
using the <a href="#proxy_ignore_headers">proxy_ignore_headers</a> directive.
</p><a name="proxy_connect_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_connect_timeout</strong> <code><i>time</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_connect_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines a timeout for establishing a connection with the proxied server.
It should be noted that this timeout cannot usually exceed 75 seconds.
</p><a name="proxy_cookie_domain"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cookie_domain</strong> <code>off</code>;</code><br><code><strong>proxy_cookie_domain</strong> <code><i>domain</i></code> <code><i>replacement</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cookie_domain off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 1.1.15.

            </p></div><p>
Sets a text that should be changed in the <code>domain</code>
attribute of the “Set-Cookie” header fields of a
proxied server response.
Suppose a proxied server returned the header field
“Set-Cookie” with the attribute
“<code>domain=localhost</code>”.
The directive
</p> <blockquote class="example"><pre>
proxy_cookie_domain localhost example.org;
</pre></blockquote><p> 
will rewrite this attribute to
“<code>domain=example.org</code>”.
</p><p>
A dot at the beginning of the <code><i>domain</i></code> and
<code><i>replacement</i></code> strings, and the <code>domain</code>
attribute is ignored.
Matching is case-insensitive.
</p><p>
The strings <code><i>domain</i></code> and <code><i>replacement</i></code>
can contain variables:
</p> <blockquote class="example"><pre>
proxy_cookie_domain www.$host $host;
</pre></blockquote><p> 
</p><p>
A directive can also be specified using regular expressions.
In this case, <code><i>domain</i></code> should start from
the “<code>~</code>” symbol.
A regular expression can contain named and positional captures,
and <code><i>replacement</i></code> can reference them:
</p> <blockquote class="example"><pre>
proxy_cookie_domain ~\.(?P&lt;sl_domain&gt;[-0-9a-z]+\.[a-z]+)$ $sl_domain;
</pre></blockquote><p> 
</p><p>
There could be several <code>proxy_cookie_domain</code> directives:
</p> <blockquote class="example"><pre>
proxy_cookie_domain localhost example.org;
proxy_cookie_domain ~\.([a-z]+\.[a-z]+)$ $1;
</pre></blockquote><p> 
</p><p>
The <code>off</code> parameter cancels all
<code>proxy_cookie_domain</code> directives on the current level:
</p> <blockquote class="example"><pre>
proxy_cookie_domain off;
proxy_cookie_domain localhost example.org;
proxy_cookie_domain www.example.org example.org;
</pre></blockquote><p> 
</p><a name="proxy_cookie_path"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_cookie_path</strong> <code>off</code>;</code><br><code><strong>proxy_cookie_path</strong> <code><i>path</i></code> <code><i>replacement</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_cookie_path off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 1.1.15.

            </p></div><p>
Sets a text that should be changed in the <code>path</code>
attribute of the “Set-Cookie” header fields of a
proxied server response.
Suppose a proxied server returned the header field
“Set-Cookie” with the attribute
“<code>path=/two/some/uri/</code>”.
The directive
</p> <blockquote class="example"><pre>
proxy_cookie_path /two/ /;
</pre></blockquote><p> 
will rewrite this attribute to
“<code>path=/some/uri/</code>”.
</p><p>
The strings <code><i>path</i></code> and <code><i>replacement</i></code>
can contain variables:
</p> <blockquote class="example"><pre>
proxy_cookie_path $uri /some$uri;
</pre></blockquote><p> 
</p><p>
A directive can also be specified using regular expressions.
In this case, <code><i>path</i></code> should either start from
the “<code>~</code>” symbol for a case-sensitive matching,
or from the “<code>~*</code>” symbols for case-insensitive
matching.
A regular expression can contain named and positional captures,
and <code><i>replacement</i></code> can reference them:
</p> <blockquote class="example"><pre>
proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre></blockquote><p> 
</p><p>
There could be several <code>proxy_cookie_path</code> directives:
</p> <blockquote class="example"><pre>
proxy_cookie_path /one/ /;
proxy_cookie_path / /two/;
</pre></blockquote><p> 
</p><p>
The <code>off</code> parameter cancels all
<code>proxy_cookie_path</code> directives on the current level:
</p> <blockquote class="example"><pre>
proxy_cookie_path off;
proxy_cookie_path /two/ /;
proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</pre></blockquote><p> 
</p><a name="proxy_headers_hash_bucket_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_headers_hash_bucket_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_headers_hash_bucket_size 64;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets the bucket <code><i>size</i></code> for hash tables
used by the <a href="#proxy_hide_header">proxy_hide_header</a> and <a href="#proxy_set_header">proxy_set_header</a>
directives.
Details of setting up hash tables are provided in a separate
<a href="../hash.html">document</a>.
</p><a name="proxy_headers_hash_max_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_headers_hash_max_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_headers_hash_max_size 512;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets the maximum <code><i>size</i></code> of hash tables
used by the <a href="#proxy_hide_header">proxy_hide_header</a> and <a href="#proxy_set_header">proxy_set_header</a>
directives.
Details of setting up hash tables are provided in a separate
<a href="../hash.html">document</a>.
</p><a name="proxy_hide_header"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_hide_header</strong> <code><i>field</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
By default,
nginx does not pass the header fields “Date”,
“Server”, “X-Pad”, and
“X-Accel-...” from the response of a proxied
server to a client.
The <code>proxy_hide_header</code> directive sets additional fields
that will not be passed.
If, on the contrary, the passing of fields needs to be permitted,
the <a href="#proxy_pass_header">proxy_pass_header</a> directive can be used.
</p><a name="proxy_http_version"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_http_version</strong> <code>1.0</code> | <code>1.1</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_http_version 1.0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table><p>This directive appeared in version 1.1.4.

            </p></div><p>
Sets the HTTP protocol version for proxying.
By default, version 1.0 is used.
Version 1.1 is recommended for use with
<a href="ngx_http_upstream_module.html#keepalive">keepalive</a>
connections.
</p><a name="proxy_ignore_client_abort"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_ignore_client_abort</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_ignore_client_abort off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Determines should the connection with a proxied server be
closed if a client closes a connection without waiting
for a response.
</p><a name="proxy_ignore_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_ignore_headers</strong> <code><i>field</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Disables processing of certain response header fields from the proxied server.
The following fields can be ignored: “X-Accel-Redirect”,
“X-Accel-Expires”, “X-Accel-Limit-Rate” (1.1.6),
“X-Accel-Buffering” (1.1.6),
“X-Accel-Charset” (1.1.6), “Expires”,
“Cache-Control”, and “Set-Cookie” (0.8.44).
</p><p>
If not disabled, processing of these header fields has the following effect:
</p> <ul>

<li>
“X-Accel-Expires”, “Expires”,
“Cache-Control”, and “Set-Cookie”
set parameters of response <a href="#proxy_cache_valid">caching</a>;
</li>

<li>
“X-Accel-Redirect” performs an
<a href="ngx_http_core_module.html#internal">internal
redirect</a> to the specified URI;
</li>

<li>
“X-Accel-Limit-Rate” sets a
<a href="ngx_http_core_module.html#limit_rate">rate
limit</a> for transmission of a response to a client;
</li>

<li>
“X-Accel-Buffering” enables or disables
<a href="#proxy_buffering">buffering</a> of a response;
</li>

<li>
“X-Accel-Charset” sets the desired
<a href="ngx_http_charset_module.html#charset">charset</a>
of a response.
</li>

</ul><p> 
</p><a name="proxy_intercept_errors"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_intercept_errors</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_intercept_errors off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Determines whether proxied responses with codes greater than or equal
to 400 should be passed to a client or be redirected to nginx for processing
using the <a href="ngx_http_core_module.html#error_page">error_page</a> directive.
</p><a name="proxy_max_temp_file_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_max_temp_file_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_max_temp_file_size 1024m;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
When <a href="#proxy_buffering">buffering</a> of responses from the proxied
server is enabled, and the whole response does not fit into memory buffers
set by the <a href="#proxy_buffer_size">proxy_buffer_size</a> and <a href="#proxy_buffers">proxy_buffers</a>
directives, part of a response can be saved to a temporary file.
This directive sets the maximum <code><i>size</i></code> of a temporary file.
The size of data written to a temporary file at a time is set
by the <a href="#proxy_temp_file_write_size">proxy_temp_file_write_size</a> directive.
</p><p>
Value of zero disables buffering of responses to temporary files.
</p><a name="proxy_method"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_method</strong> <code><i>method</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Specifies the HTTP <code><i>method</i></code> to use in requests forwarded
to the proxied server instead of the method from the client request.
</p><a name="proxy_next_upstream"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_next_upstream</strong> 
    <code>error</code> |
    <code>timeout</code> |
    <code>invalid_header</code> |
    <code>http_500</code> |
    <code>http_502</code> |
    <code>http_503</code> |
    <code>http_504</code> |
    <code>http_404</code> |
    <code>off</code>
    ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_next_upstream error timeout;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Specifies in which cases a request should be passed to the next server:
</p> <dl class="compact">

<dt><code>error</code></dt>
<dd>an error occurred while establishing a connection with the
server, passing it a request, or reading the response header;</dd>

<dt><code>timeout</code></dt>
<dd>a timeout has occurred while establishing a connection with the
server, passing it a request, or reading the response header;</dd>

<dt><code>invalid_header</code></dt>
<dd>a server returned empty or invalid response;</dd>

<dt><code>http_500</code></dt>
<dd>a server returned a response with the code 500;</dd>

<dt><code>http_502</code></dt>
<dd>a server returned a response with the code 502;</dd>

<dt><code>http_503</code></dt>
<dd>a server returned a response with the code 503;</dd>

<dt><code>http_504</code></dt>
<dd>a server returned a response with the code 504;</dd>

<dt><code>http_404</code></dt>
<dd>a server returned a response with the code 404;</dd>

<dt><code>off</code></dt>
<dd>disables passing a request to the next server.</dd>

</dl><p> 
</p><p>
It should be understood that passing a request to the next server is
only possible if a client was not sent anything yet.
That is, if an error or a timeout occurs in the middle of
transferring a response, fixing this is impossible.
</p><a name="proxy_no_cache"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_no_cache</strong> <code><i>string</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines conditions under which the response will not be saved to a cache.
If at least one value of the string parameters is not empty and is not
equal to “0” then the response will not be saved:
</p> <blockquote class="example"><pre>
proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;
proxy_no_cache $http_pragma    $http_authorization;
</pre></blockquote><p> 
Can be used along with the <a href="#proxy_cache_bypass">proxy_cache_bypass</a> directive.
</p><a name="proxy_pass"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_pass</strong> <code><i>URL</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>location</code>, <code>if in location</code>, <code>limit_except</code><br>
                </td>
                </tr>
            </table></div><p>
Sets the protocol and address of a proxied server, and an optional URI
to which a location should be mapped.
A protocol can be specified as
“<code>http</code>” or “<code>https</code>”.
An address can be specified as a domain name or IP address,
and an optional port:
</p> <blockquote class="example"><pre>
proxy_pass http://localhost:8000/uri/;
</pre></blockquote><p> 
or as a UNIX-domain socket path specified after the word
“<code>unix</code>” and enclosed in colons:
</p> <blockquote class="example"><pre>
proxy_pass http://unix:/tmp/backend.socket:/uri/;
</pre></blockquote><p> 
</p><p>
If a domain name resolves to several addresses, all of them will be
used in a round-robin fashion.
In addition, an address can be specified as a
<a href="ngx_http_upstream_module.html">server group</a>.
</p><p>
A request URI is passed to the server as follows:
</p> <ul>

<li>
If <code>proxy_pass</code> is specified with URI,
when passing a request to the server, part of a
<a href="ngx_http_core_module.html#location">normalized</a>
request URI matching the location is replaced by a URI
specified in the directive:
<blockquote class="example"><pre>
location /name/ {
    proxy_pass http://127.0.0.1/remote/;
}
</pre></blockquote>
</li>

<li>
If <code>proxy_pass</code> is specified without URI,
a request URI is passed to the server in the same form
as sent by a client when processing an original request,
or the full normalized request URI is passed
when processing the changed URI:
<blockquote class="example"><pre>
location /some/path/ {
    proxy_pass http://127.0.0.1;
}
</pre></blockquote>
<blockquote class="note">
Before version 1.1.12,
if <code>proxy_pass</code> is specified without a URI,
an original request URI might be passed
instead of the changed URI in some cases.
</blockquote>
</li>
</ul><p> 
</p><p>
In some cases, part of a request URI to be replaced cannot be determined:
</p> <ul>

<li>
When location is specified using a regular expression.
<p>
In this case, the directive should be specified without URI.
</p>
</li>

<li>
When URI is changed inside a proxied location using the
<a href="ngx_http_rewrite_module.html#rewrite">rewrite</a> directive,
and this same configuration will be used to process a request
(<code>break</code>):
<blockquote class="example"><pre>
location /name/ {
    rewrite    /name/([^/]+) /users?name=$1 break;
    proxy_pass http://127.0.0.1;
}
</pre></blockquote>
<p>
In this case, a URI specified in the directive is ignored and
the full changed request URI is passed to the server.
</p>
</li>
</ul><p> 
</p><p>
A server name, its port and passed URI can also be specified using variables:
</p> <blockquote class="example"><pre>
proxy_pass http://$host$uri;
</pre></blockquote><p> 
or even like this:
</p> <blockquote class="example"><pre>
proxy_pass $request;
</pre></blockquote><p> 
</p><p>
In this case the server name is searched among the described
<a href="ngx_http_upstream_module.html">server groups</a>,
and if not found is determined using a
<a href="ngx_http_core_module.html#resolver">resolver</a>.
</p><a name="proxy_pass_header"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_pass_header</strong> <code><i>field</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Permits to pass <a href="#proxy_hide_header">otherwise disabled</a> header
fields from a proxied server to a client.
</p><a name="proxy_read_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_read_timeout</strong> <code><i>time</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_read_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines a timeout for reading a response from the proxied server.
A timeout is only set between two successive read operations,
not for the transmission of the whole response.
If a proxied server does not transmit anything within this time,
a connection is closed.
</p><a name="proxy_pass_request_body"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_pass_request_body</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_pass_request_body on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
If disabled, the original request body will not be passed
to the proxied server.
</p> <blockquote class="example"><pre>
location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";

    proxy_pass ...
}
</pre></blockquote><p> 
See also the <a href="#proxy_set_header">proxy_set_header</a> and
<a href="#proxy_pass_request_headers">proxy_pass_request_headers</a> directives.
</p><a name="proxy_pass_request_headers"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_pass_request_headers</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_pass_request_headers on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
If disabled, header fields of the original request will not be passed to the
proxied server.
</p> <blockquote class="example"><pre>
location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_headers off;
    proxy_pass_request_body off;

    proxy_pass ...
}
</pre></blockquote><p> 
See also the <a href="#proxy_set_header">proxy_set_header</a> and
<a href="#proxy_pass_request_body">proxy_pass_request_body</a> directives.
</p><a name="proxy_redirect"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_redirect</strong> <code>default</code>;</code><br><code><strong>proxy_redirect</strong> <code>off</code>;</code><br><code><strong>proxy_redirect</strong> <code><i>redirect</i></code> <code><i>replacement</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_redirect default;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets a text that should be changed in the header fields
“Location” and “Refresh” of a response
from the proxied server.
Suppose a proxied server returned the header field
“<code>Location: http://localhost:8000/two/some/uri/</code>”.
The directive
</p> <blockquote class="example"><pre>
proxy_redirect http://localhost:8000/two/ http://frontend/one/;
</pre></blockquote><p> 
will rewrite this string to
“<code>Location: http://frontend/one/some/uri/</code>”.
</p><p>
A server name may be omitted from the <code><i>replacement</i></code> string:
</p> <blockquote class="example"><pre>
proxy_redirect http://localhost:8000/two/ /;
</pre></blockquote><p> 
then the primary server’s name and a port, if different from 80,
will be substituted.
</p><p>
The default replacement specified by the <code>default</code> parameter
uses the parameters of the
<a href="ngx_http_core_module.html#location">location</a> and
<a href="#proxy_pass">proxy_pass</a> directives.
Hence, the two configurations below are equivalent:
</p> <blockquote class="example"><pre>
location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect default;
</pre></blockquote><p> 

</p> <blockquote class="example"><pre>
location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect http://upstream:port/two/ /one/;
</pre></blockquote><p> 
The <code>default</code> parameter is not permitted if
<a href="#proxy_pass">proxy_pass</a> is specified using variables.
</p><p>
A <code><i>replacement</i></code> string can contain variables:
</p> <blockquote class="example"><pre>
proxy_redirect http://localhost:8000/ http://$host:$server_port/;
</pre></blockquote><p> 
</p><p>
A <code><i>redirect</i></code> can also contain (1.1.11) variables:
</p> <blockquote class="example"><pre>
proxy_redirect http://$proxy_host:8000/ /;
</pre></blockquote><p> 
</p><p>
A directive can be specified (1.1.11) using regular expressions.
In this case, <code><i>redirect</i></code> should either start from
the “<code>~</code>” symbol for a case-sensitive matching,
or from the “<code>~*</code>” symbols for case-insensitive
matching.
A regular expression can contain named and positional captures,
and <code><i>replacement</i></code> can reference them:
</p> <blockquote class="example"><pre>
proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
</pre></blockquote><p> 
</p><p>
There could be several <code>proxy_redirect</code> directives:
</p> <blockquote class="example"><pre>
proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre></blockquote><p> 
</p><p>
The <code>off</code> parameter cancels all
<code>proxy_redirect</code> directives on the current level:
</p> <blockquote class="example"><pre>
proxy_redirect off;
proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</pre></blockquote><p> 
</p><p>
Using this directive it is also possible to add host names to relative
redirects issued by a proxied server:
</p> <blockquote class="example"><pre>
proxy_redirect / /;
</pre></blockquote><p> 
</p><a name="proxy_send_lowat"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_send_lowat</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_send_lowat 0;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
If set to a non-zero value, nginx will try to minimize the number
of send operations on outgoing connections to a proxied server by using either
<code>NOTE_LOWAT</code> flag of the
<a href="../events.html#kqueue">kqueue</a> method,
or the <code>SO_SNDLOWAT</code> socket option,
with the specified <code><i>size</i></code>.
</p><p>
This directive is ignored on Linux, Solaris, and Windows.
</p><a name="proxy_send_timeout"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_send_timeout</strong> <code><i>time</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_send_timeout 60s;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets a timeout for transmitting a request to the proxied server.
A timeout is only set between two successive write operations,
not for the transmission of the whole request.
If a proxied server does not receive anything within this time,
a connection is closed.
</p><a name="proxy_set_body"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_set_body</strong> <code><i>value</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            
            —
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Allows to redefine request body passed to the proxied server.
A <code><i>value</i></code> can contain text, variables, and their combination.
</p><a name="proxy_set_header"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_set_header</strong> <code><i>field</i></code> <code><i>value</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_set_header Host $proxy_host;</pre><pre>proxy_set_header Connection close;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Allows to redefine or append fields to the request header
<a href="#proxy_pass_request_headers">passed</a> to the proxied server.
A <code><i>value</i></code> can contain text, variables, and their combination.
These directives are inherited from the previous level if and
only if there are no
<code>proxy_set_header</code>
directives defined on the current level.
By default, only two fields are redefined:
</p> <blockquote class="example"><pre>
proxy_set_header Host       $proxy_host;
proxy_set_header Connection close;
</pre></blockquote><p> 
</p><p>
An unchanged “Host” request header field can be passed like this:
</p> <blockquote class="example"><pre>
proxy_set_header Host       $http_host;
</pre></blockquote><p> 
</p><p>
However, if this field is not present in a client request header then
nothing will be passed.
In such a case it is better to use the <code>$host</code> variable - its
value equals the server name in the “Host” request header
field, or the primary server name if this field is not present:
</p> <blockquote class="example"><pre>
proxy_set_header Host       $host;
</pre></blockquote><p> 
</p><p>
In addition, a server name can be passed together with a port of the
proxied server:
</p> <blockquote class="example"><pre>
proxy_set_header Host       $host:$proxy_port;
</pre></blockquote><p> 
</p><p>
If the value of a header field is an empty string then this
field will not be passed to a proxied server:
</p> <blockquote class="example"><pre>
proxy_set_header Accept-Encoding "";
</pre></blockquote><p> 
</p><a name="proxy_ssl_session_reuse"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_ssl_session_reuse</strong> <code>on</code> | <code>off</code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_ssl_session_reuse on;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Determines whether SSL sessions can be reused when working with
the proxied server.
If the errors
“<code>SSL3_GET_FINISHED:digest check failed</code>”
appear in the logs, try to disable session reuse.
</p><a name="proxy_store"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_store</strong> 
    <code>on</code> |
    <code>off</code> |
    <code><i>string</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_store off;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Enables saving of files to a disk.
The <code>on</code> parameter saves files with paths
corresponding to the directives
<a href="ngx_http_core_module.html#alias">alias</a> or
<a href="ngx_http_core_module.html#root">root</a>.
The <code>off</code> parameter disables saving of files.
In addition, the file name can be set explicitly using the
<code><i>string</i></code> with variables:
</p> <blockquote class="example"><pre>
proxy_store /data/www$original_uri;
</pre></blockquote><p> 
</p><p>
The modification time of files is set according to the received
“Last-Modified” response header field.
A response is first written to a temporary file, then a file is renamed.
Starting from version 0.8.9 temporary files and the persistent store
can be put on different file systems but be aware that in this case
a file is copied across two file systems instead of the cheap rename operation.
It is thus recommended that for any given location both saved files and a
directory holding temporary files set by the <a href="#proxy_temp_path">proxy_temp_path</a>
directive are put on the same file system.
</p><p>
This directive can be used to create local copies of static unchangeable
files, e.g.:
</p> <blockquote class="example"><pre>
location /images/ {
    root                   /data/www;
    open_file_cache_errors off;
    error_page             404 = /fetch$uri;
}

location /fetch/ {
    internal;

    proxy_pass             http://backend/;
    proxy_store            on;
    proxy_store_access     user:rw group:rw all:r;
    proxy_temp_path        /data/temp;

    alias                  /data/www/;
}
</pre></blockquote><p> 
</p><p>
or like this:
</p> <blockquote class="example"><pre>
location /images/ {
    root               /data/www;
    error_page         404 = @fetch;
}

location @fetch {
    internal;

    proxy_pass         http://backend;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    root               /data/www;
}
</pre></blockquote><p> 
</p><a name="proxy_store_access"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_store_access</strong> <code><i>users</i></code>:<code><i>permissions</i></code> ...;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_store_access user:rw;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Sets access permissions for newly created files and directories, e.g.:
</p> <blockquote class="example"><pre>
proxy_store_access user:rw group:rw all:r;
</pre></blockquote><p> 
</p><p>
If any <code>group</code> or <code>all</code> access permissions
are specified then <code>user</code> permissions may be omitted:
</p> <blockquote class="example"><pre>
proxy_store_access group:rw all:r;
</pre></blockquote><p> 
</p><a name="proxy_temp_file_write_size"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_temp_file_write_size</strong> <code><i>size</i></code>;</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_temp_file_write_size 8k|16k;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Limits the <code><i>size</i></code> of data written to a temporary file
at a time, when buffering of responses from the proxied server
to temporary files is enabled.
By default, <code><i>size</i></code> is limited by two buffers set by the
<a href="#proxy_buffer_size">proxy_buffer_size</a> and <a href="#proxy_buffers">proxy_buffers</a> directives.
The maximum size of a temporary file is set by the
<a href="#proxy_max_temp_file_size">proxy_max_temp_file_size</a> directive.
</p><a name="proxy_temp_path"></a><div class="directive"><table cellspacing="0">
                <tr>
                <td>
            syntax:
                </td>
                <td>
            <code><strong>proxy_temp_path</strong> 
    <code><i>path</i></code>
    [<code><i>level1</i></code>
    [<code><i>level2</i></code>
    [<code><i>level3</i></code>]]];</code><br>
                </td>
                </tr>
            
                <tr>
                <td>
            default:
                </td>
                <td>
            <pre>proxy_temp_path proxy_temp;</pre>
                </td>
                </tr>
            
                <tr>
                <td>
            context:
                </td>
                <td>
            <code>http</code>, <code>server</code>, <code>location</code><br>
                </td>
                </tr>
            </table></div><p>
Defines a directory for storing temporary files
with data received from proxied servers.
Up to three-level subdirectory hierarchy can be used underneath the specified
directory.
For example, in the following configuration
</p> <blockquote class="example"><pre>
proxy_temp_path /spool/nginx/proxy_temp 1 2;
</pre></blockquote><p> 
a temporary file might look like this:
</p> <blockquote class="example"><pre>
/spool/nginx/proxy_temp/<strong>7</strong>/<strong>45</strong>/00000123<strong>457</strong>
</pre></blockquote><p> 
</p>


<a name="variables"></a><center><h4>Embedded Variables</h4></center><p>
The <code>ngx_http_proxy_module</code> module supports embedded variables
that can be used to compose headers using the
<a href="#proxy_set_header">proxy_set_header</a> directive:
</p> <dl class="compact">

<dt><code>$proxy_host</code></dt>
<dd>name and port of a proxied server;</dd>

<dt><code>$proxy_port</code></dt>
<dd>port of a proxied server;</dd>

<dt><code>$proxy_add_x_forwarded_for</code></dt>
<dd>the “X-Forwarded-For” client request header field
with the <code>$remote_addr</code> variable appended to it, separated by a comma.
If the “X-Forwarded-For” field is not present in the client
request header, the <code>$proxy_add_x_forwarded_for</code> variable is equal
to the <code>$remote_addr</code> variable.</dd>
</dl><p> 
</p>

</td></tr></table></body></html>
